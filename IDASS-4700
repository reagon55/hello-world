@Test
void shouldHandleIdentityStoreEntry_whenIdentityStoreIsNotLegacy() {

    // ---------- Arrange ----------
    Map<String, String> headerMap =
            Map.of("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    Map<String, String> mandatoryFinalTransEntry = Map.of();

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(false);

    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    "cred-123",
                    null,
                    null,
                    null,
                    null,
                    null,
                    "linked-123",
                    null
            );

    Map.Entry<CredentialStore, IdentityStoreResponse> entry =
            Map.entry(credentialStore, identityStoreResponse);

    // Authenticator
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    JourneyConfiguration journeyConfiguration =
            mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));

    JourneyState journeyState = mock(JourneyState.class);
    when(journeyState.getConfig()).thenReturn(journeyConfiguration);

    // CIS response
    CustomerInformationSystemDetailsResponse cisResponse =
            new CustomerInformationSystemDetailsResponse();
    cisResponse.setCustomerId("cust-001");

    when(customerInfoSystemProxyService.getCustomerDetails(
            anyMap(),
            isNull(),
            eq("linked-123")
    )).thenReturn(cisResponse);

    
    when(configStoreProxyService.getEligibleAuthenticators(
            anyMap(),
            anyString(),
            anyList(),
            eq("SCW"),
            any(IdentityResolverRequest.class)
    )).thenReturn(List.of("OTP"));

    // ---------- Act ----------
    IdentityResolverResponse response =
            ReflectionTestUtils.invokeMethod(
                    serviceUnderTest,
                    "handleIdentityStoreEntry",
                    headerMap,
                    request,
                    journeyState,
                    mandatoryFinalTransEntry,
                    entry
            );

    // ---------- Assert ----------
    assertNotNull(response);

    verify(customerInfoSystemProxyService, times(1))
            .getCustomerDetails(anyMap(), isNull(), eq("linked-123"));

    verify(legacyCredentialProxyService, never())
            .getEligibleAuthenticators(any(), any(), any());
}

------------------------------------------------------------------------------------------------------
@Test
void shouldHandleIdentityStoreEntry_whenIdentityStoreIsNotLegacy() {

    // ---------- Arrange ----------

    Map<String, String> headerMap =
            Map.of("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    Map<String, String> mandatoryFinalTransEntry = Map.of();

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(false);

    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    "cred-123",
                    null,
                    null,
                    null,
                    null,
                    null,
                    "linked-123",
                    null
            );

    Map.Entry<CredentialStore, IdentityStoreResponse> entry =
            Map.entry(credentialStore, identityStoreResponse);

    // ----- Authenticator -----
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    // ----- Journey config -----
    JourneyConfiguration journeyConfiguration =
            mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));   // ‚úÖ MUST be Authenticator

    JourneyState journeyState = mock(JourneyState.class);
    when(journeyState.getConfig())
            .thenReturn(journeyConfiguration);

    // ----- CIS response -----
    CustomerInformationSystemDetailsResponse cisResponse =
            new CustomerInformationSystemDetailsResponse();
    cisResponse.setCustomerId("cust-001");

    when(customerInfoSystemProxyService.getCustomerDetails(
            anyMap(),
            isNull(),                // ‚úÖ CRITICAL FIX
            eq("linked-123")
    )).thenReturn(cisResponse);

    // ---------- Act ----------
    IdentityResolverResponse response =
            ReflectionTestUtils.invokeMethod(
                    serviceUnderTest,
                    "handleIdentityStoreEntry",
                    headerMap,
                    request,
                    journeyState,
                    mandatoryFinalTransEntry,
                    entry
            );

    // ---------- Assert ----------
    assertNotNull(response);

    verify(customerInfoSystemProxyService, times(1))
            .getCustomerDetails(anyMap(), isNull(), eq("linked-123"));

    verify(legacyCredentialProxyService, never())
            .getEligibleAuthenticators(any(), any(), any());
}

------------------------------------------------------------------------------------------------------
@ExtendWith(MockitoExtension.class)
class UserIdentityResolverServiceTest {

    @InjectMocks
    private UserIdentityResolverService serviceUnderTest;

    @Mock
    private CustomerInfoSystemProxyService customerInfoSystemProxyService;

    @Mock
    private LegacyCredentialProxyService legacyCredentialProxyService;

    // ---------------- TEST ----------------

    @Test
    void shouldHandleIdentityStoreEntry_whenIdentityStoreIsNotLegacy() {

        // ---------- Arrange ----------

        Map<String, String> headerMap =
                Map.of("X-LBG-TOKEN", "dummy-token");

        IdentityResolverRequest request = new IdentityResolverRequest();
        request.setCredentialId("cred-123");

        Map<String, String> mandatoryFinalTransEntry = Map.of();

        CredentialStore credentialStore = new CredentialStore();
        credentialStore.setStore("SCW");
        credentialStore.setLegacy(false);

        IdentityStoreResponse identityStoreResponse =
                new IdentityStoreResponse(
                        "cred-123",
                        null,
                        null,
                        null,
                        null,
                        null,
                        "linked-123",
                        null
                );

        Map.Entry<CredentialStore, IdentityStoreResponse> entry =
                Map.entry(credentialStore, identityStoreResponse);

        // ---- Authenticator ----
        Authenticator otp = mock(Authenticator.class);
        when(otp.getType()).thenReturn("OTP");

        // ---- Journey config ----
        JourneyConfiguration journeyConfiguration =
                mock(JourneyConfiguration.class);
        when(journeyConfiguration.getAuthenticators())
                .thenReturn(List.of(otp));

        JourneyState journeyState = mock(JourneyState.class);
        when(journeyState.getConfig())
                .thenReturn(journeyConfiguration);

        // ---- CIS response ----
        CustomerInformationSystemDetailsResponse cisResponse =
                new CustomerInformationSystemDetailsResponse();
        cisResponse.setCustomerId("cust-001");

        
        when(customerInfoSystemProxyService.getCustomerDetails(
                anyMap(),
                isNull(),
                eq("linked-123")
        )).thenReturn(cisResponse);

        // ---------- Act ----------

        IdentityResolverResponse response =
                ReflectionTestUtils.invokeMethod(
                        serviceUnderTest,
                        "handleIdentityStoreEntry",
                        headerMap,
                        request,
                        journeyState,
                        mandatoryFinalTransEntry,
                        entry
                );

        // ---------- Assert ----------

        assertNotNull(response);

        verify(customerInfoSystemProxyService, times(1))
                .getCustomerDetails(anyMap(), isNull(), eq("linked-123"));

        verify(legacyCredentialProxyService, never())
                .getEligibleAuthenticators(any(), any(), any());
    }
}

------------------------------------------------------------------------------------------------------
@Test
void shouldHandleIdentityStoreEntry_whenIdentityStoreIsNotLegacy() {

    Map<String, String> headerMap = Map.of("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    Map<String, String> mandatoryFinalTransEntry = Map.of();

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(false);

    IdentityStoreResponse identityStoreResponse =
        new IdentityStoreResponse(
            "cred-123",
            null,
            null,
            null,
            null,
            null,
            "linked-123",
            null
        );

    Map.Entry<CredentialStore, IdentityStoreResponse> entry =
        Map.entry(credentialStore, identityStoreResponse);

    // Authenticator
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators()).thenReturn(List.of(otp));

    JourneyState journeyState = mock(JourneyState.class);
    when(journeyState.getConfig()).thenReturn(journeyConfiguration);

    CustomerInformationSystemDetailsResponse cisResponse =
        new CustomerInformationSystemDetailsResponse();
    cisResponse.setCustomerId("cust-001");

    when(customerInfoSystemProxyService.getCustomerDetails(
        anyMap(),
        isNull(),                 // üîë FIX
        eq("linked-123")
    )).thenReturn(cisResponse);

    // Act
    IdentityResolverResponse response =
        ReflectionTestUtils.invokeMethod(
            serviceUnderTest,
            "handleIdentityStoreEntry",
            headerMap,
            request,
            journeyState,
            mandatoryFinalTransEntry,
            entry
        );

    // Assert
    assertNotNull(response);

    verify(customerInfoSystemProxyService, times(1))
        .getCustomerDetails(anyMap(), isNull(), eq("linked-123"));

    verify(legacyCredentialProxyService, never())
        .getEligibleAuthenticators(any(), any(), any());
}

-------------------------------------------------------------------------------------
@Test
void shouldHandleIdentityStoreEntry_whenIdentityStoreIsNotLegacy() {

    // -------- Arrange --------
    Map<String, String> headerMap = Map.of("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    Map<String, String> mandatoryFinalTransEntry = Map.of();

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(false);

    IdentityStoreResponse identityStoreResponse =
        new IdentityStoreResponse(
            "cred-123",
            null,
            null,
            null,
            null,
            null,
            "linked-123",
            null
        );

    Map.Entry<CredentialStore, IdentityStoreResponse> entry =
        Map.entry(credentialStore, identityStoreResponse);

    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators()).thenReturn(List.of("OTP"));

    JourneyState journeyState = mock(JourneyState.class);
    when(journeyState.getConfig()).thenReturn(journeyConfiguration);

    CustomerInformationSystemDetailsResponse cisResponse =
        new CustomerInformationSystemDetailsResponse();
    cisResponse.setCustomerId("cust-001");

    when(customerInfoSystemProxyService.getCustomerDetails(
        anyMap(),
        anyString(),
        eq("linked-123")
    )).thenReturn(cisResponse);

    
    doReturn(List.of("OTP"))
        .when(serviceUnderTest)
        .getEligibleAuthenticators(
            anyMap(),
            anyString(),
            anyList(),
            anyString(),
            any(IdentityResolverRequest.class)
        );

    // -------- Act --------
    IdentityResolverResponse response =
        ReflectionTestUtils.invokeMethod(
            serviceUnderTest,
            "handleIdentityStoreEntry",
            headerMap,
            request,
            journeyState,
            mandatoryFinalTransEntry,
            entry
        );

    // -------- Assert --------
    assertNotNull(response);

    verify(customerInfoSystemProxyService, times(1))
        .getCustomerDetails(anyMap(), anyString(), eq("linked-123"));

    verify(legacyCredentialProxyService, never())
        .getEligibleAuthenticators(any(), any(), any());
}


-------------------------------------------------------------------------------
@Test
void shouldThrowException_whenNoCommonAuthenticators() {

    // -------- Arrange --------

    Map<String, String> headerMap =
        Map.of("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    Map<String, String> mandatoryFinalTransEntry = Map.of();

    CredentialsStore credentialsStore = new CredentialsStore();
    credentialsStore.setStore("SCW");
    credentialsStore.setLegacy(true);

    IdentityStoreResponse identityStoreResponse =
        mock(IdentityStoreResponse.class);
    when(identityStoreResponse.getLinkedCustomerId())
        .thenReturn("linked-123");

    Map.Entry<CredentialsStore, IdentityStoreResponse> entry =
        Map.entry(credentialsStore, identityStoreResponse);

    JourneyConfiguration journeyConfiguration =
        mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
        .thenReturn(List.of()); // NO configured authenticators

    JourneyState journeyState = mock(JourneyState.class);
    when(journeyState.getConfig())
        .thenReturn(journeyConfiguration);

    when(legacyCredentialProxyService.getEligibleAuthenticators(
        anyMap(),
        eq("linked-123"),
        eq("SCW")
    )).thenReturn(List.of("OTP")); // Eligible but no intersection

    // -------- Act + Assert --------

    assertThatThrownBy(() ->
        ReflectionTestUtils.invokeMethod(
            serviceUnderTest,
            "handleIdentityStoreEntry",
            headerMap,
            request,
            journeyState,
            mandatoryFinalTransEntry,
            entry
        )
    )
    .isInstanceOf(CoordinatorException.class)
    .hasMessageContaining("No authenticator to proceed");
}

-----------------------------------------------------------------------------------------
@Test
void shouldThrowException_whenNoCommonAuthenticators() {
    when(journeyConfiguration.getAuthenticators())
        .thenReturn(List.of());

    when(legacyCredentialProxyService.getEligibleAuthenticators(...))
        .thenReturn(List.of("OTP"));

    assertThatThrownBy(() ->
        ReflectionTestUtils.invokeMethod(
            serviceUnderTest,
            "handleIdentityStoreEntry",
            headerMap,
            request,
            journeyState,
            mandatoryFinalTransEntry,
            entry
        )
    ).isInstanceOf(CoordinatorException.class)
     .hasMessageContaining("No authenticator to proceed");
}


---------------------------------------------------------------------------
--@Test
void shouldHandleIdentityStoreEntry_whenIdentityStoreIsLegacy() {

    // ---------- Arrange ----------
    Map<String, String> headerMap = Map.of("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    Map<String, String> mandatoryFinalTransEntry = Map.of();

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(true);

    IdentityStoreResponse identityStoreResponse = new IdentityStoreResponse(
            "cred-123",
            null,
            null,
            null,
            null,
            null,
            "linked-123",
            null
    );

    Map.Entry<CredentialStore, IdentityStoreResponse> entry =
            Map.entry(credentialStore, identityStoreResponse);

    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators()).thenReturn(List.of());

    JourneyState journeyState = mock(JourneyState.class);
    when(journeyState.getConfig()).thenReturn(journeyConfiguration);

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq("linked-123"),
            eq("SCW")
    )).thenReturn(List.of("OTP"));

    // ---------- Act ----------
    IdentityResolverResponse response =
            ReflectionTestUtils.invokeMethod(
                    serviceUnderTest,
                    "handleIdentityStoreEntry",
                    headerMap,
                    request,
                    journeyState,
                    mandatoryFinalTransEntry,
                    entry
            );

    // ---------- Assert ----------
    assertNotNull(response);

    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), eq("linked-123"), eq("SCW"));

    verify(customerInfoSystemProxyService, never()).getCustomerDetails(any(), any(), any());
}

----------------------------------------------------------------------------------
@Test
void shouldHandleIdentityStoreEntry_whenIdentityStoreIsNotLegacy() {

    // ---------- Arrange ----------
    Map<String, String> headerMap = Map.of("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    Map<String, String> mandatoryFinalTransEntry = Map.of();

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(false);

    IdentityStoreResponse identityStoreResponse = new IdentityStoreResponse(
            "cred-123",
            null,
            null,
            null,
            null,
            null,
            "linked-123",
            null
    );

    Map.Entry<CredentialStore, IdentityStoreResponse> entry =
            Map.entry(credentialStore, identityStoreResponse);

    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators()).thenReturn(List.of());

    JourneyState journeyState = mock(JourneyState.class);
    when(journeyState.getConfig()).thenReturn(journeyConfiguration);

    CustomerInformationSystemDetailsResponse cisResponse =
            new CustomerInformationSystemDetailsResponse();
    cisResponse.setCustomerId("cust-001");

    when(customerInfoSystemProxyService.getCustomerDetails(
            anyMap(),
            anyString(),
            eq("linked-123")
    )).thenReturn(cisResponse);

    // ---------- Act ----------
    IdentityResolverResponse response =
            ReflectionTestUtils.invokeMethod(
                    serviceUnderTest,
                    "handleIdentityStoreEntry",
                    headerMap,
                    request,
                    journeyState,
                    mandatoryFinalTransEntry,
                    entry
            );

    // ---------- Assert ----------
    assertNotNull(response);

    verify(customerInfoSystemProxyService, times(1))
            .getCustomerDetails(anyMap(), anyString(), eq("linked-123"));

    verify(legacyCredentialProxyService, never()).getEligibleAuthenticators(any(), any(), any());
}

------------------------------------------------------------------------------------------
@Test
void shouldReturnLegacyIdentityStoreEntry_whenIdentityStoreIsLegacy() {
    // Arrange
    Map<String, String> headerMap = Map.of("X-LBG-TOKEN", "dummy");
    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(true);

    IdentityStoreResponse legacyResponse = mock(IdentityStoreResponse.class);

    when(legacyCredentialProxyService.getLegacyCredential(
            eq(headerMap),
            eq("cred-123"),
            eq("SCW")
    )).thenReturn(legacyResponse);

    // Act
    @SuppressWarnings("unchecked")
    Map.Entry<CredentialStore, IdentityStoreResponse> result =
            (Map.Entry<CredentialStore, IdentityStoreResponse>)
                    ReflectionTestUtils.invokeMethod(
                            serviceUnderTest,
                            "getIdentityStoreEntry",
                            headerMap,
                            request,
                            credentialStore,
                            false
                    );

    // Assert
    assertNotNull(result);
    assertEquals(credentialStore, result.getKey());
    assertEquals(legacyResponse, result.getValue());

    verify(legacyCredentialProxyService, times(1))
            .getLegacyCredential(anyMap(), eq("cred-123"), eq("SCW"));

    verify(identityStoreService, never())
            .getUserCredential(any(), any(), any(), anyBoolean());
}


----------------------------------------------
@Test
void shouldReturnNonLegacyIdentityStoreEntry_whenIdentityStoreIsNotLegacy() {
    // Arrange
    Map<String, String> headerMap = Map.of("X-LBG-TOKEN", "dummy");
    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    CredentialStore credentialStore = new CredentialStore();
    credentialStore.setStore("SCW");
    credentialStore.setLegacy(false);

    IdentityStoreResponse response = mock(IdentityStoreResponse.class);

    when(identityStoreService.getUserCredential(
            eq(headerMap),
            eq("cred-123"),
            eq(credentialStore),
            eq(true)
    )).thenReturn(response);

    // Act
    @SuppressWarnings("unchecked")
    Map.Entry<CredentialStore, IdentityStoreResponse> result =
            (Map.Entry<CredentialStore, IdentityStoreResponse>)
                    ReflectionTestUtils.invokeMethod(
                            serviceUnderTest,
                            "getIdentityStoreEntry",
                            headerMap,
                            request,
                            credentialStore,
                            true
                    );

    // Assert
    assertNotNull(result);
    assertEquals(credentialStore, result.getKey());
    assertEquals(response, result.getValue());

    verify(identityStoreService, times(1))
            .getUserCredential(anyMap(), eq("cred-123"), eq(credentialStore), eq(true));

    verify(legacyCredentialProxyService, never())
            .getLegacyCredential(any(), any(), any());
}

----------------------------------------------------------------------------------------
@Test
    void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

        /* ===================== Arrange ===================== */

        Map<String, String> headerMap = new HashMap<>();
        headerMap.put("X-LBG-TOKEN", "dummy-token");

        IdentityResolverRequest request = new IdentityResolverRequest();
        request.setCredentialId(CREDENTIAL_ID);

        // ---------- Authenticator ----------
        Authenticator otp = mock(Authenticator.class);
        when(otp.getType()).thenReturn("OTP");

        // ---------- Journey config ----------
        JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
        when(journeyConfiguration.getAuthenticators())
                .thenReturn(List.of(otp));

        when(journeyState.getConfig())
                .thenReturn(journeyConfiguration);

        // ---------- IdentityStore ----------
        when(identityStore.getStore()).thenReturn("SCW");
        when(identityStore.isLegacy()).thenReturn(true);

        // ---------- Identity store response (REAL OBJECT) ----------
        IdentityStoreResponse identityStoreResponse =
                new IdentityStoreResponse(
                        CREDENTIAL_ID,
                        null,
                        null,
                        null,
                        null,
                        null,
                        LINKED_CUSTOMER_ID,
                        null
                );

        when(identityStoreService.getUserCredential(
                anyMap(),
                eq(CREDENTIAL_ID),
                any(CredentialStore.class),
                anyBoolean()
        )).thenReturn(identityStoreResponse);

        // ---------- Legacy proxy ----------
        when(legacyCredentialProxyService.getEligibleAuthenticators(
                anyMap(),
                eq(LINKED_CUSTOMER_ID),
                eq("SCW")
        )).thenReturn(List.of("OTP"));

        /* ===================== Act ===================== */

        serviceUnderTest.resolveUserIdentity(headerMap, request);

        /* ===================== Assert ===================== */

        verify(legacyCredentialProxyService, times(1))
                .getEligibleAuthenticators(anyMap(), eq(LINKED_CUSTOMER_ID), eq("SCW"));

        verifyNoInteractions(customerInfoSystemProxyService);
    }
}
---------------------------------------------------------------------------------------------
@Test
void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

    // ---------- Arrange ----------

    Map<String, String> headerMap = new HashMap<>();
    headerMap.put("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    // Authenticator (NO setters ‚Üí mock)
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    // Journey configuration
    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));

    // Journey state (CRITICAL)
    when(journeyState.getConfig())
            .thenReturn(journeyConfiguration);

    // Credential store
    when(credentialStore.isLegacy()).thenReturn(true);
    when(credentialStore.getStore()).thenReturn("SCW");

    // Identity store response (REAL OBJECT ‚Äî constructor only)
    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    "cred-123",        // credentialId
                    null,              // customerId
                    null,              // group
                    null,              // status
                    null,              // passwordStatus
                    null,              // accountCreationDate
                    "linked-123",      // linkedCustomerId
                    null               // currentGlobalCounter
            );

    // IdentityStoreService (MOST IMPORTANT MOCK)
    when(identityStoreService.getUserCredential(
            anyMap(),
            eq("cred-123"),
            eq(credentialStore),
            anyBoolean()
    )).thenReturn(identityStoreResponse);

    // Legacy proxy response
    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq("linked-123"),
            eq("SCW")
    )).thenReturn(List.of("OTP"));

    // ---------- Act ----------
    serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- Assert ----------
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), anyString(), anyString());

    verifyNoInteractions(customerInfoSystemProxyService);
}

---------------------------------------------------------------------------------------
@Test
void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

    // ---------- Arrange ----------

    Map<String, String> headerMap = new HashMap<>();
    headerMap.put("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    // Authenticator (NO setters ‚Üí must mock)
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));

    when(journeyState.getConfig())
            .thenReturn(journeyConfiguration);

    // Credential store
    when(credentialStore.isLegacy()).thenReturn(true);
    when(credentialStore.getStore()).thenReturn("SCW");

    // Identity store response (REAL OBJECT ‚Äì constructor only)
    IdentityStoreResponse identityStoreResponse =
        new IdentityStoreResponse(
            "cred-123",        // credentialId
            null,              // customerId
            null,              // group
            null,              // status
            null,              // passwordStatus
            null,              // accountCreationDate
            "linked-123",      // linkedCustomerId
            null               // currentGlobalCounter
        );

    // IdentityStoreService (CRITICAL MOCK)
    when(identityStoreService.getUserCredential(
            anyMap(),
            eq("cred-123"),
            eq(credentialStore),
            anyBoolean()
    )).thenReturn(identityStoreResponse);

    // Legacy proxy
    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq("linked-123"),
            eq("SCW")
    )).thenReturn(List.of("OTP"));

    // ---------- Act ----------
    serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- Assert ----------
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), anyString(), anyString());

    verifyNoInteractions(customerInfoSystemProxyService);
}

--------------------------------------------------
@Test
void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

    // ---------- Arrange ----------

    Map<String, String> headerMap = new HashMap<>();
    headerMap.put("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    // ---- Authenticator (NO setters ‚Üí must mock)
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    // ---- Journey configuration
    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));

    // ---- Journey state (CRITICAL)
    when(journeyState.getConfig())
            .thenReturn(journeyConfiguration);

    // ---- Credential store
    when(credentialStore.isLegacy()).thenReturn(true);
    when(credentialStore.getStore()).thenReturn("SCW");

    // ---- Identity store response (REAL OBJECT ‚Äì setters allowed)
    IdentityStoreResponse identityStoreResponse = new IdentityStoreResponse();
    identityStoreResponse.setCredentialId("cred-123");
    identityStoreResponse.setLinkedCustomerId("linked-123");

    // ---- IdentityStoreService (MOST IMPORTANT MOCK)
    when(identityStoreService.getUserCredential(
            anyMap(),
            eq("cred-123"),
            eq(credentialStore),
            anyBoolean()
    )).thenReturn(identityStoreResponse);

    // ---- Legacy proxy response
    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq("linked-123"),
            eq("SCW")
    )).thenReturn(List.of("OTP"));

    // ---------- Act ----------
    serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- Assert ----------
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), anyString(), anyString());

    verifyNoInteractions(customerInfoSystemProxyService);
}

--------------------------------
@Test
void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

    // ---------- Arrange ----------
    Map<String, String> headerMap = new HashMap<>();
    headerMap.put("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    // ---- Authenticator (NO setters)
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));

    when(journeyState.getConfig())
            .thenReturn(journeyConfiguration);

    // ---- Identity store
    when(credentialStore.isLegacy()).thenReturn(true);
    when(credentialStore.getStore()).thenReturn("SCW");

    IdentityStoreResponse identityStoreResponse = new IdentityStoreResponse();
    identityStoreResponse.setCredentialId("cred-123");
    identityStoreResponse.setLinkedCustomerId("linked-123");

    
    when(identityStoreService.getUserCredential(
            anyMap(),
            eq("cred-123"),
            eq(credentialStore),
            anyBoolean()
    )).thenReturn(identityStoreResponse);

    // ---- Legacy proxy
    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq("linked-123"),
            eq("SCW")
    )).thenReturn(List.of("OTP"));

    // ---------- Act ----------
    serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- Assert ----------
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), eq("linked-123"), eq("SCW"));

    verifyNoInteractions(customerInfoSystemProxyService);
}

---------------------------------------------------------------------------------------
@Test
void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

    // ---------- Arrange ----------

    Map<String, String> headerMap = new HashMap<>();
    headerMap.put("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    // ---- Authenticator (NO setters, must mock)
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));

    when(journeyState.getConfig())
            .thenReturn(journeyConfiguration);

    // ---- Identity store
    when(credentialStore.isLegacy()).thenReturn(true);
    when(credentialStore.getStore()).thenReturn("SCW");

    IdentityStoreResponse storeResponse = new IdentityStoreResponse();
    storeResponse.setLinkedCustomerId("linked-123");
    storeResponse.setCredentialId("cred-123");

    Map.Entry<CredentialStore, IdentityStoreResponse> entry =
            new AbstractMap.SimpleEntry<>(credentialStore, storeResponse);

    // üî• THIS WAS MISSING IN ALL YOUR TESTS
    when(identityStoreService.getIdentityStoreEntry(anyString()))
            .thenReturn(entry);

    // ---- Legacy proxy
    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            anyString(),
            anyString()
    )).thenReturn(List.of("OTP"));

    // ---------- Act ----------
    serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- Assert ----------
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), anyString(), anyString());

    verifyNoInteractions(customerInfoSystemProxyService);
}

---------------------------------------------------
@Test
    void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

        // ---------- Arrange ----------

        Map<String, String> headerMap = new HashMap<>();
        headerMap.put("X-LBG-TOKEN", "dummy-token");

        IdentityResolverRequest request = new IdentityResolverRequest();
        request.setCredentialId("cred-123");

        // ---- Authenticator (NO setters, must be mocked)
        Authenticator otp = mock(Authenticator.class);
        when(otp.getType()).thenReturn("OTP");

        // ---- Journey configuration
        JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
        when(journeyConfiguration.getAuthenticators())
                .thenReturn(List.of(otp));

        // ---- Journey state (CRITICAL WIRING)
        when(journeyState.getConfig())
                .thenReturn(journeyConfiguration);

        // ---- Identity store
        when(credentialStore.isLegacy()).thenReturn(true);
        when(credentialStore.getStore()).thenReturn("scw");

        // ---- Legacy proxy response
        when(legacyCredentialProxyService.getEligibleAuthenticators(
                anyMap(),
                anyString(),
                anyString()
        )).thenReturn(List.of("OTP"));

        // ---------- Act ----------
        serviceUnderTest.resolveUserIdentity(headerMap, request);

        // ---------- Assert ----------
        verify(legacyCredentialProxyService, times(1))
                .getEligibleAuthenticators(anyMap(), anyString(), anyString());

        verifyNoInteractions(customerInfoSystemProxyService);
    }

--------------------------------
@Test
void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

    // -------- Arrange --------
    Map<String, String> headerMap = new HashMap<>();
    headerMap.put("X-LBG-TOKEN", "dummy-token");

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId("cred-123");

    // Authenticator mock 
    Authenticator otp = mock(Authenticator.class);
    when(otp.getType()).thenReturn("OTP");

    // Journey configuration mock
    JourneyConfiguration journeyConfiguration = mock(JourneyConfiguration.class);
    when(journeyConfiguration.getAuthenticators())
            .thenReturn(List.of(otp));

    // Journey state mock (THIS WAS MISSING ‚ùó)
    when(journeyState.getConfig())
            .thenReturn(journeyConfiguration);

    // Identity store
    when(credentialStore.isLegacy()).thenReturn(true);
    when(credentialStore.getStore()).thenReturn("scw");

    // Legacy proxy response
    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            anyString(),
            anyString()
    )).thenReturn(List.of("OTP"));

    // -------- Act --------
    serviceUnderTest.resolveUserIdentity(headerMap, request);

    // -------- Assert --------
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), anyString(), anyString());

    verifyNoInteractions(customerInfoSystemProxyService);
}

------------------------------------------------------------------------------------------------
@Test
    void shouldCallLegacyEligibleAuthenticators_whenIdentityStoreIsLegacy() {

        // ---------- Arrange ----------

        Map<String, String> headerMap = new HashMap<>();
        headerMap.put("X-LBG-TOKEN", "dummy-token");

        IdentityResolverRequest request = new IdentityResolverRequest();
        request.setCredentialId("cred-123");

        // journey config
        when(journeyState.getConfig()).thenReturn(journeyConfiguration);
        when(journeyConfiguration.getAuthenticators())
                .thenReturn(List.of(new Authenticator("OTP")));

        // identity store
        when(identityStore.isLegacy()).thenReturn(true);
        when(identityStore.getStore()).thenReturn("SCW");

        // legacy service response
        when(legacyCredentialProxyService.getEligibleAuthenticators(
                anyMap(),
                anyString(),
                anyString()
        )).thenReturn(List.of("OTP"));

        // ---------- Act ----------
        serviceUnderTest.resolveUserIdentity(headerMap, request);

        // ---------- Assert ----------
        verify(legacyCredentialProxyService, times(1))
                .getEligibleAuthenticators(anyMap(), anyString(), anyString());

        verifyNoInteractions(customerInfoSystemProxyService);
    }

----------------------------------------------------------------
@Test
    void shouldCallLegacyApi_HappyPathLegacy() {

        Map<String, String> headerMap = Map.of("x-request-id", "test");

        IdentityResolverRequest request = new IdentityResolverRequest();
        request.setCredentialId("CRED_123");

        IdentityStoreResponse identityStoreResponse =
                new IdentityStoreResponse(
                        "CRED_123",
                        null,
                        null,
                        null,
                        null,
                        null,
                        "LINKED_123",
                        null
                );

        // Correct mocks
        when(configStoreProxyService.getJourneyConfigurationById(any()))
                .thenReturn(journeyConfig);

        when(journeyConfig.isDynamicLinkingEnabled())
                .thenReturn(false);   // LEGACY PATH

        when(identityStoreService.getUserCredential(
                anyMap(),
                eq("CRED_123"),
                any(),
                any()
        )).thenReturn(identityStoreResponse);

        when(legacyCredentialProxyService.getEligibleAuthenticators(
                anyMap(),
                eq("LINKED_123"),
                anyString()
        )).thenReturn(mock(CustomerInformationSystemResponse.class));

        // Act
        IdentityResolverResponse response =
                serviceUnderTest.resolveUserIdentity(headerMap, request);

        // Assert
        assertNotNull(response);

        verify(legacyCredentialProxyService, times(1))
                .getEligibleAuthenticators(anyMap(), eq("LINKED_123"), anyString());

        verifyNoMoreInteractions(customerInfoSystemProxyService);
    }
----------------------------------------------------------------
@Test
    void shouldCallLegacyApi_HappyPathLegacy() {

        Map<String, String> headerMap = Map.of("x-request-id", "test");

        IdentityResolverRequest request = new IdentityResolverRequest();
        request.setCredentialId("CRED_123");

        IdentityStoreResponse identityStoreResponse =
                new IdentityStoreResponse(
                        "CRED_123",
                        null,
                        null,
                        null,
                        null,
                        null,
                        "LINKED_123",
                        null
                );

        // mocks
        when(configStoreProxyService.getJourneyConfigurationById(any()))
                .thenReturn(journeyConfig);

        when(journeyConfig.isDynamicLinkingEnabled())
                .thenReturn(false);   // LEGACY PATH

        when(identityStoreService.getUserCredential(
                anyMap(),
                eq("CRED_123"),
                any(),
                any()
        )).thenReturn(identityStoreResponse);

        when(legacyCredentialProxyService.getEligibleAuthenticators(
                anyMap(),
                eq("LINKED_123"),
                anyString()
        )).thenReturn(mock(CustomerInformationSystemResponse.class));

        // Act
        IdentityResolverResponse response =
                serviceUnderTest.resolveUserIdentity(headerMap, request);

        // Assert
        assertNotNull(response);

        verify(legacyCredentialProxyService, times(1))
                .getEligibleAuthenticators(anyMap(), eq("LINKED_123"), anyString());

        verifyNoMoreInteractions(customerInfoSystemProxyService);
    }
----------------------------------------------------------------------------------
@Test
void shouldCallLegacyCapi_HappyPathLegacy() {

    Map<String, String> headerMap =
            createHeaderMap(createRequestHeaders());

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    when(configStoreProxyService.getJourneyConfigurationById(any()))
            .thenReturn(journeyConfig);

    when(journeyConfig.getConfig())
            .thenReturn(config);

    when(config.isDynamicLinkingEnabled())
            .thenReturn(false);

    when(identityStoreService.getUserCredential(
            anyMap(), eq(CREDENTIAL_ID), any(), any()))
            .thenReturn(identityStoreResponse);

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()))
            .thenReturn(legacyResponse);

    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    assertNotNull(response);

    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), eq(LINKED_CUSTOMER_ID), anyString());

    verifyNoMoreInteractions(customerInfoSystemProxyService);
}

------------------------------------------------------
@Test
void shouldCallLegacyCapi_whenIdentityStoreIsLegacy() {

    // ---------- GIVEN ----------

    // headers
    Map<String, String> headerMap =
            createHeaderMap(createRequestHeaders());

    // request
    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    // journey config
    JourneyConfiguration journeyConfig = createJourneyConfig();
    when(configStoreProxyService.getJourneyConfigurationById(anyMap()))
            .thenReturn(journeyConfig);

    // identity store response ‚Üí LEGACY
    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    CREDENTIAL_ID,
                    null,           // customerId
                    null,           // group
                    null,           // status
                    null,           // passwordStatus
                    null,           // accountCreationDate
                    LINKED_CUSTOMER_ID, // üî• THIS MAKES IT LEGACY
                    null            // currentGlobalCounter
            );

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            any()
    )).thenReturn(identityStoreResponse);

    // legacy CAPI response
    CustomerInformationSystemResponse legacyResponse =
            prepareCustomerInformationSystemResponse();

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()
    )).thenReturn(legacyResponse);

    // ---------- WHEN ----------
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- THEN ----------
    assertNotNull(response);

    // legacy path MUST be used
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(
                    anyMap(),
                    eq(LINKED_CUSTOMER_ID),
                    anyString()
            );

    // non-legacy path MUST NOT be used
    verify(customerInfoSystemProxyService, never())
            .getEligibleAuthenticatorsById(
                    any(), any(), any(), any(), any(), any()
            );
}

-------------------------------------------------------------------------
@Test
void shouldCallLegacyCapi_whenIdentityStoreIsLegacy() {

    // ---------- GIVEN ----------

    // headers
    Map<String, String> headerMap =
            createHeaderMap(createRequestHeaders());

    // request
    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    // journey config
    JourneyConfiguration journeyConfig = createJourneyConfig();
    when(configStoreProxyService.getJourneyConfigurationById(anyMap()))
            .thenReturn(journeyConfig);

    // -------- IdentityStoreResponse (LEGACY = TRUE) --------
    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    CREDENTIAL_ID,
                    null,
                    null,
                    null,
                    null,
                    null,
                    LINKED_CUSTOMER_ID,   // legacy trigger
                    null
            );

    // identityStoreService mock
    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            any()
    )).thenReturn(identityStoreResponse);

    // legacy CAPI response
    CustomerInformationSystemResponse legacyResponse =
            prepareCustomerInformationSystemResponse();

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()
    )).thenReturn(legacyResponse);

    // ---------- WHEN ----------
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- THEN ----------
    assertNotNull(response);

    // legacy path MUST be called
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(
                    anyMap(),
                    eq(LINKED_CUSTOMER_ID),
                    anyString()
            );

    // non-legacy path MUST NOT be called
    verify(customerInfoSystemProxyService, never())
            .getEligibleAuthenticatorsById(
                    any(),
                    any(),
                    any(),
                    any(),
                    any(),
                    any(),
                    any()
            );
}

-------------------------------------------------------------------
@Test
void shouldCallLegacyCapi_whenIdentityStoreIsLegacy() {

    // GIVEN
    Map<String, String> headerMap =
            createHeaderMap(createRequestHeaders());

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                CREDENTIAL_ID,
                null,
                null,
                null,
                null,
                null,
                LINKED_CUSTOMER_ID, // legacy trigger
                null
            );

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            any()
    )).thenReturn(identityStoreResponse);

    CustomerInformationSystemResponse legacyResponse =
            prepareCustomerInformationSystemResponse();

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()
    )).thenReturn(legacyResponse);

    // WHEN
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // THEN
    assertNotNull(response);

    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), eq(LINKED_CUSTOMER_ID), anyString());

    verify(customerInfoSystemProxyService, never())
            .getEligibleAuthenticatorsById(any(), any(), any(), any(), any(), any(), any());
}

---------------------------------------------------------------------
@Test
void shouldCallLegacyCapi_whenIdentityStoreIsLegacy() {

    // GIVEN
    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    IdentityStoreResponse identityStoreResponse =
        new IdentityStoreResponse(
            CREDENTIAL_ID,
            null,
            null,
            null,
            null,
            null,
            LINKED_CUSTOMER_ID, // legacy trigger
            null
        );

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            any()
    )).thenReturn(identityStoreResponse);

    CustomerInformationSystemResponse legacyResponse =
        prepareCustomerInformationSystemResponse();

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()
    )).thenReturn(legacyResponse);

    // WHEN
    IdentityResolverResponse response =
        serviceUnderTest.resolveUserIdentity(headerMap, request);

    // THEN
    assertNotNull(response);

    verify(legacyCredentialProxyService, times(1))
        .getEligibleAuthenticators(anyMap(), eq(LINKED_CUSTOMER_ID), anyString());

    verify(customerInfoSystemProxyService, never())
        .getEligibleAuthenticatorsById(any(), any(), any(), any(), any(), any(), any());
}


-------------------------------------------------------------------------------------------
@Test
void shouldCallLegacyCapi_whenIdentityStoreIsLegacy() {

    // GIVEN
    Map<String, String> headerMap = createHeaderMap(createRequestHeaders());

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    JourneyConfiguration journeyConfig = createJourneyConfig();
    when(configStoreProxyService.getJourneyConfigurationById(anyMap()))
            .thenReturn(journeyConfig);

    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    CREDENTIAL_ID,
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    LINKED_CUSTOMER_ID, // legacy trigger
                    null
            );

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            any()
    )).thenReturn(identityStoreResponse);

    CustomerInformationSystemResponse legacyResponse =
            prepareCustomerInformationSystemResponse();

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()
    )).thenReturn(legacyResponse);

    // WHEN
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // THEN
    assertNotNull(response);

    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), eq(LINKED_CUSTOMER_ID), anyString());

    verify(customerInfoSystemProxyService, never())
            .getEligibleAuthenticatorsById(any(), any(), any(), any(), any(), any(), any());
}

-------------------------------------------------------------------------------------------------------------
@Test
void shouldCallNonLegacyApi_whenIdentityStoreIsNotLegacy() {

    // GIVEN
    Map<String, String> headerMap = createHeaderMap(createRequestHeaders());

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    JourneyConfiguration journeyConfig = createJourneyConfig();
    when(configStoreProxyService.getJourneyConfigurationById(anyMap()))
            .thenReturn(journeyConfig);

    IdentityStoreResponse identityStoreResponse = new IdentityStoreResponse();
    identityStoreResponse.setCredentialId(CREDENTIAL_ID);
    identityStoreResponse.setLinkedCustomerId(LINKED_CUSTOMER_ID);
    identityStoreResponse.setLegacy(false);

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            eq(IS_IDENTIFIER_TYPE_TOKEN)
    )).thenReturn(identityStoreResponse);

    when(customerInfoSystemProxyService.getEligibleAuthenticatorsById(
            anyMap(),
            any(),
            any(),
            any(),
            any(),
            any()
    )).thenReturn(prepareCustomerInformationSystemResponse());

    // WHEN
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // THEN
    assertNotNull(response);

    verify(customerInfoSystemProxyService, times(1))
            .getEligibleAuthenticatorsById(any(), any(), any(), any(), any(), any());

    verify(legacyCredentialProxyService, never())
            .getEligibleAuthenticators(anyMap(), anyString(), anyString());
}

-----------------------------------------------------------------------------
@Test
void shouldCallLegacyCapi_whenIdentityStoreIsLegacy() {

    // GIVEN
    Map<String, String> headerMap = createHeaderMap(createRequestHeaders());

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    JourneyConfiguration journeyConfig = createJourneyConfig();
    when(configStoreProxyService.getJourneyConfigurationById(anyMap()))
            .thenReturn(journeyConfig);

    IdentityStoreResponse identityStoreResponse = new IdentityStoreResponse();
    identityStoreResponse.setCredentialId(CREDENTIAL_ID);
    identityStoreResponse.setLinkedCustomerId(LINKED_CUSTOMER_ID);
    identityStoreResponse.setLegacy(true);

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            eq(IS_IDENTIFIER_TYPE_TOKEN)
    )).thenReturn(identityStoreResponse);

    CustomerInformationSystemResponse legacyResponse =
            prepareCustomerInformationSystemResponse();

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()
    )).thenReturn(legacyResponse);

    // WHEN
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // THEN
    assertNotNull(response);

    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), eq(LINKED_CUSTOMER_ID), anyString());

    verify(customerInfoSystemProxyService, never())
            .getEligibleAuthenticatorsById(any(), any(), any(), any(), any(), any());
}

-------------------------------------------------------------------------------------
@Test
void shouldCallEligibleAuthenticatorsApi_WhenIdentityStoreIsNotLegacy() {
    // ---------- GIVEN ----------
    Map<String, String> headerMap = createHeaderMap(createRequestHeaders());

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    JourneyConfiguration journeyConfig = createJourneyConfig();
    when(configStoreProxyService.getJourneyConfigurationById(anyMap()))
            .thenReturn(journeyConfig);

    // Identity store ‚Üí LEGACY = false
    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    CREDENTIAL_ID,
                    null,
                    null,
                    null,
                    null,
                    null,
                    LINKED_CUSTOMER_ID,
                    false   //  NON-LEGACY
            );

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            eq(ISIDENTIFIERYPETOKEN)))
            .thenReturn(identityStoreResponse);

    when(customerInfoSystemProxyService.getEligibleAuthenticatorsById(
            anyMap(),
            anyString(),
            anyString(),
            anyList(),
            any(),
            any()))
            .thenReturn(prepareCustomerInformationSystemResponse());

    // ---------- WHEN ----------
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- THEN ----------
    assertNotNull(response);

    //  Non-legacy API MUST be called
    verify(customerInfoSystemProxyService, times(1))
            .getEligibleAuthenticatorsById(any(), any(), any(), any(), any(), any());

    //  Legacy CAPI MUST NOT be called
    verify(legacyCredentialProxyService, never())
            .getEligibleAuthenticators(anyMap(), anyString(), anyString());
}

------------------------------------------------------------------------------------------------
@Test
void shouldCallLegacyCapi_WhenIdentityStoreIsLegacy() {
    // ---------- GIVEN ----------
    Map<String, String> headerMap = createHeaderMap(createRequestHeaders());

    IdentityResolverRequest request = new IdentityResolverRequest();
    request.setCredentialId(CREDENTIAL_ID);

    JourneyConfiguration journeyConfig = createJourneyConfig();
    when(configStoreProxyService.getJourneyConfigurationById(anyMap()))
            .thenReturn(journeyConfig);

    // Identity store ‚Üí LEGACY = true
    IdentityStoreResponse identityStoreResponse =
            new IdentityStoreResponse(
                    CREDENTIAL_ID,
                    null,
                    null,
                    null,
                    null,
                    null,
                    LINKED_CUSTOMER_ID,
                    true   // LEGACY FLAG
            );

    when(identityStoreService.getUserCredential(
            anyMap(),
            eq(CREDENTIAL_ID),
            any(CredentialStore.class),
            eq(ISIDENTIFIERYPETOKEN)))
            .thenReturn(identityStoreResponse);

    // Legacy CAPI response
    CustomerInformationSystemResponse legacyResponse =
            prepareCustomerInformationSystemResponse();

    when(legacyCredentialProxyService.getEligibleAuthenticators(
            anyMap(),
            eq(LINKED_CUSTOMER_ID),
            anyString()))
            .thenReturn(legacyResponse);

    // ---------- WHEN ----------
    IdentityResolverResponse response =
            serviceUnderTest.resolveUserIdentity(headerMap, request);

    // ---------- THEN ----------
    assertNotNull(response);

    // Legacy CAPI MUST be called
    verify(legacyCredentialProxyService, times(1))
            .getEligibleAuthenticators(anyMap(), eq(LINKED_CUSTOMER_ID), anyString());

    // Non-legacy API MUST NOT be called
    verify(customerInfoSystemProxyService, never())
            .getEligibleAuthenticatorsById(any(), any(), any(), any(), any(), any());

    // Optional but powerful
    assertNotNull(response.getEligibleAuthenticators());
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------
Fix implemented and validated locally.

Changes:
‚Ä¢ Updated Validate-API error handling to use central error configuration
‚Ä¢ Mapped expired authSessionId (cache 404) to a specific business error message instead of a generic response

Testing:
‚Ä¢ Added unit test to simulate expired session scenario
‚Ä¢ Verified Validate-API throws CoordinatorException with message:
"Session ID not found or has expired"

This ensures the API now returns a clear and deterministic error message as per acceptance criteria and prevents future regression.
--------------------------------------------------------------------------------------------------------------------------
The test verifies that when the cached session lookup fails (simulating an expired or invalid authSessionId),
the service propagates the final CoordinatorException produced by the handleErrors() method.

This confirms that:

handleErrors() correctly interprets the underlying REST failure

The expected 404 error code (IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404) is returned
-----------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() throws Exception {

    // Load real error config
    ErrorConfig errorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(errorConfig);

    validateService = new ValidateValueService(
            cacheMgmtProxyService,
            authServicesMap,
            errorConfig
    );

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI flow
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);

    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // -------------------------------
    // SIMULATE the final exception AFTER handleErrors()
    // -------------------------------
    Error error404 = errorConfig.getErrorMap()
            .get(ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name());

    CoordinatorException coordinator404 =
            new CoordinatorException(error404);

    // NOW mock cache call to throw that
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenThrow(coordinator404);

    // Prepare request
    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    // Assertion
    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()
    );
}

---------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() throws Exception {

    // Load real error config
    ErrorConfig errorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(errorConfig);

    validateService = new ValidateValueService(
            cacheMgmtProxyService,
            authServicesMap,
            errorConfig
    );

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI valid
    when(authServicesMap.containsKey(AuthType.MI.getValue())).thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue())).thenReturn(miProxyService);

    // -------------------------
    // MOCK restTemplate.exchange() so that handleErrors() executes
    // -------------------------
    HttpClientErrorException http404 =
            new HttpClientErrorException(HttpStatus.NOT_FOUND, "Session not found");

    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenCallRealMethod(); // Important

    doThrow(http404)
            .when(restTemplate)
            .exchange(
                    anyString(),
                    eq(HttpMethod.GET),
                    any(HttpEntity.class),
                    eq(JourneyCache.class)
            );

    // Call API
    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()
    );
}

--------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() throws Exception {

    // Load real error config exactly like other tests
    ErrorConfig errorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(errorConfig);

    // Re-create service with real errorConfig
    validateService = new ValidateValueService(
            cacheMgmtProxyService,
            authServicesMap,
            errorConfig
    );

    // ---------- Mock REST Failure so handleErrors() executes ----------

    HttpStatusCodeException http404 =
            new HttpClientErrorException(HttpStatus.NOT_FOUND, "Session not found");

    // Mock restTemplate INSIDE CacheMgmtProxyService
    when(cacheMgmtProxyService.getJourneyStateBySessionId(anyMap()))
            .thenThrow(http404);

    // ---------- Mock MI authType valid ----------
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);

    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // ---------- Headers for the call ----------
    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Dummy request body
    ValidateApiRequest request = new ValidateApiRequest();
    AuthType authType = AuthType.MI;

    // ---------- ACT + ASSERT ----------
    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, request)
    );

    // Verify error code coming from error-mapping.yml
    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()
    );
}

------------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() throws Exception {

    // 1Ô∏è‚É£ Load real error config exactly like other tests
    ErrorConfig errorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(errorConfig);

    validateService = new ValidateValueService(
            cacheMgmtProxyService,
            authServicesMap,
            errorConfig
    );

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // 2Ô∏è‚É£ Mock MI flow
    when(authServicesMap.containsKey(AuthType.MI.getValue())).thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue())).thenReturn(miProxyService);

    // 3Ô∏è‚É£ Mock journeyCache null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    // 4Ô∏è‚É£ Assert correct error code from YAML
    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()
    );
}

------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() throws Exception {

    // Load real error config
    ErrorConfig realErrorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(realErrorConfig);

    validateService = new ValidateValueService(
            cacheMgmtProxyService,
            authServicesMap,
            realErrorConfig
    );

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI valid
    when(authServicesMap.containsKey(AuthType.MI.getValue())).thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue())).thenReturn(miProxyService);

    // Journey cache null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers)).thenReturn(null);

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()
    );
}

-----------------
real
@Test
void shouldThrow404WhenJourneyCacheIsNull() throws Exception {

    // Load real errorConfig
    ErrorConfig realErrorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(realErrorConfig);

    validateService = new ValidateValueService(
            cacheMgmtProxyService,
            authServicesMap,
            realErrorConfig   // <- REAL ONE injected
    );

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // Journey cache returns null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()   // NOW error is NOT NULL
    );
}

----------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() throws Exception {

    // Load real errorConfig just like other tests
    ErrorConfig errorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(errorConfig);
    validateService = new ValidateValueService(cacheMgmtProxyService, authServicesMap, errorConfig);

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI flow
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // Journey cache returns null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()
    );
}

-----------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() {

    // Load real errorConfig just like other tests
    ErrorConfig errorConfig = new ErrorConfig();
    TestUtils.loadErrorConfig(errorConfig);
    validateService = new ValidateValueService(cacheMgmtProxyService, authServicesMap, errorConfig);

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI flow
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // Journey cache returns null ‚Üí this triggers your new null check
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
            thrown.getError().getCode()
    );
}

-----------------
Added a null check for journeyCache and now throw the 404 error before using journeyCache.getData() 
to avoid NPE and align with the error-mapping yaml.

Wrote a new JUnit test:
shouldThrow404WhenJourneyCacheIsNull()

The test verifies that the service throws the expected error:
IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404
as per the acceptance criteria for this ticket.

-----------------------------------
I investigated the issue in ValidateValueService and tried multiple approaches to reproduce a 404 scenario for unit testing.

Findings:
1. The existing ValidateValueService implementation does not throw the 404 error anywhere in the validateValue() flow.
   - Only 401 (unsupported authType) and 500 (JSON conversion failure) are thrown.
   - The JourneyCache == null case currently does not use the 404 error mapping; instead, it proceeds further which causes a NullPointerException.

2. Because the service does not trigger the 404 errorConfig mapping path, the corresponding unit test fails as the expected error object is never constructed.

3. To complete the test, the code needs to explicitly throw:
       IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404
   when cacheMgmtProxyService.getJourneyStateBySessionId(headers) returns null.

Suggestion:
- Add a null check for journeyCache and throw the 404 error before using journeyCache.getData() to avoid NPE and align with the error-mapping yaml.

Once this change is added, I will update and validate the unit test.

-------------------------------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() {

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI authType
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // Mock journeyCache returned null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    // Prepare mock error
    Error error404 = new Error();
    error404.setCode("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404");
    error404.setMessage("Journey Cache is null");

    // THIS WAS MISSING IN YOUR TEST (root cause of NPE)
    when(errorConfig.getErrorMap())
            .thenReturn(Map.of(
                    ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
                    error404
            ));

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404",
            thrown.getError().getCode());
}

----------------------------------------------------------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() {

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI authType to be valid
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // Mock journeyCache returned null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    // Prepare 404 error
    Error error404 = new Error();
    error404.setCode("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404");

    // Correct mock for errorConfig
    when(errorConfig.getErrorMap())
            .thenReturn(Map.of(
                    ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404.name(),
                    error404
            ));

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404",
                 thrown.getError().getCode());
}

------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() {

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock MI authType to be valid
    when(authServicesMap.containsKey(AuthType.MI.getValue()))
            .thenReturn(true);
    when(authServicesMap.get(AuthType.MI.getValue()))
            .thenReturn(miProxyService);

    // Mock journeyCache returned null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    // Prepare 404 error
    Error error404 = new Error();
    error404.setCode("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404");

    when(errorConfig.getErrorMap())
            .thenReturn(Map.of("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404", error404));

    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404",
            thrown.getError().getCode());
}

--------------------------------------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() {

    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock: journey cache returned null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    // Prepare Error object for 404
    Error error404 = new Error();
    error404.setCode("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404");

    // Mock errorConfig.getErrorMap()
    when(errorConfig.getErrorMap())
            .thenReturn(Map.of("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404", error404));

    // Dummy inputs
    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    // Assert exception thrown
    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404",
            thrown.getError().getCode());
}

---------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() {

    // headers
    Map<String, String> headers = Map.of("session-id", "ABC123");

    // 1. cache returns null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    // 2. prepare the Error object (NO constructor)
    Error error404 = new Error();
    error404.setCode("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404");
    error404.setMessage("Session ID not found or has expired");

    // 3. Expected exception produced by exception factory
    CoordinatorException expectedEx = new CoordinatorException(error404);

    when(coordinatorExceptionFactory.buildException(
            ErrorCodes.IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404))
            .thenReturn(expectedEx);

    // 4. dummy inputs
    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    // 5. assert exception thrown
    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> validateService.validateValue(headers, authType, validateRequest)
    );

    assertEquals("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404",
            thrown.getError().getCode());
}

-------------------------------
@Test
void shouldThrow404WhenJourneyCacheIsNull() {

    // headers
    Map<String, String> headers = Map.of("session-id", "ABC123");

    // Mock: journeyCache returned null
    when(cacheMgmtProxyService.getJourneyStateBySessionId(headers))
            .thenReturn(null);

    // Prepare Error Object
    Error error404 = new Error();
    error404.setCode("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404");

    when(errorConfig.getErrorMap())
            .thenReturn(Map.of("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404", error404));

    // Mock authType & request (simple placeholders)
    AuthType authType = AuthType.MI;
    ValidateApiRequest validateRequest = new ValidateApiRequest();

    // Assert expected exception
    CoordinatorException ex = assertThrows(
            CoordinatorException.class,
            () -> validateValueService.validateValue(headers, authType, validateRequest)
    );

    assertEquals("IAU_SSI_COORDINATOR_VALIDATE_API_ERR_404", ex.getError().getCode());
}

----------------------------------------------------------------------
Add these fields to IdentityResolverResponse

// -------- Legacy Credential Fields --------
private String legacyCredentialId;
private String legacyLinkedCustomerId;
private String legacyUserName;
private String legacyStatus;
private String legacyPasswordStatus;
private Boolean legacyIsMISet;
private List<String> legacyGroups;

private String legacyAccountCreationDate;
private String legacyLastStatusChangeDate;
private String legacyPasswordChangeDate;
private String legacyLastLoggedInTime;
private String legacyPasswordExpiryDate;

private Integer legacyGlobalCounter;

-------------------------------------------------------------------
private void populateLegacyCredentialFields(IdentityResolverResponse response, JsonNode legacyResponse) {

    if (legacyResponse == null || legacyResponse.isNull()) {
        return;
    }

    // Example fields based on legacy CAPI response
    response.setLegacyCredentialId(legacyResponse.path("credentialId").asText(null));
    response.setLegacyLinkedCustomerId(legacyResponse.path("linkedCustomerId").asText(null));
    response.setLegacyUserName(legacyResponse.path("userName").asText(null));
    response.setLegacyStatus(legacyResponse.path("status").asText(null));
    response.setLegacyPasswordStatus(legacyResponse.path("passwordStatus").asText(null));
    response.setLegacyIsMISet(legacyResponse.path("isMISet").asBoolean(false));

    // group array ‚Üí convert to List<String>
    if (legacyResponse.has("group")) {
        List<String> groups = new ArrayList<>();
        legacyResponse.get("group").forEach(node -> groups.add(node.asText()));
        response.setLegacyGroups(groups);
    }

    response.setLegacyAccountCreationDate(legacyResponse.path("accountCreationDate").asText(null));
    response.setLegacyLastStatusChangeDate(legacyResponse.path("lastStatusChangeDate").asText(null));
    response.setLegacyPasswordChangeDate(legacyResponse.path("lastPasswordChangeDate").asText(null));
    response.setLegacyLastLoggedInTime(legacyResponse.path("lastLoggedInTime").asText(null));
    response.setLegacyPasswordExpiryDate(legacyResponse.path("passwordExpiryDate").asText(null));
    response.setLegacyGlobalCounter(legacyResponse.path("currentGlobalCounter").asInt(0));
}



-----------------------------------------------------------------------
@Test
void testGetLegacyCredential_Success() {
    
    String linkedCustomerId = "cust123";
    String userName = "john";

    // Create mock JSON
    ObjectMapper mapper = new ObjectMapper();
    JsonNode mockJson = mapper.createObjectNode()
        .put("credentialId", "cred123")
        .put("userName", userName)
        .put("passwordStatus", "ACTIVE")
        .put("globalCounter", 5)
        .put("isMfaSet", true);

    // Mock RestTemplate call
    when(lbgRestTemplate.executeGetRequest(
            anyString(),
            any(HttpEntity.class),
            eq(JsonNode.class),
            eq(linkedCustomerId),
            eq(userName)
    )).thenReturn(mockJson);

    // Call service
    JsonNode result =
            legacyCredentialProxyService.getLegacyCredential(headerMap, linkedCustomerId, userName);

    // Assertions
    assertNotNull(result);
    assertEquals("cred123", result.get("credentialId").asText());
    assertEquals("john", result.get("userName").asText());
}

----------------------------------------------------------------------------------------------------------------
package com.lbg.iau.ssi.coordinator.identity.resolver.service;

import com.lbg.iau.ssi.coordinator.identity.resolver.common.LbgRestTemplate;
import com.lbg.iau.ssi.coordinator.identity.resolver.model.CustomerInformationSystemResponse;
import com.lbg.iau.ssi.coordinator.identity.resolver.model.LegacyCredentialResponse;
import com.lbg.iau.ssi.coordinator.identity.resolver.properties.CapiLegacyProperties;
import com.lbg.iau.ssi.coordinator.identity.resolver.util.ErrorUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpEntity;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class LegacyCredentialProxyServiceTest {

    @Mock
    private LbgRestTemplate lbgRestTemplate;

    @Mock
    private CapiLegacyProperties capLegacyProperties;

    @Mock
    private CapiLegacyProperties.Operations operations;

    @Mock
    private ErrorUtil errorUtil;

    @Spy
    @InjectMocks
    private LegacyCredentialProxyService legacyCredentialProxyService;

    private Map<String, String> headerMap;

    private static final String BASE_URL = "http://mock-capi1";
    private static final String CREDENTIAL_ENDPOINT = "/credentials/{credentialStore}/{partition}";
    private static final String ELIGIBLE_ENDPOINT   = "/eligible/{credentialStore}/{partition}";

    @BeforeEach
    void setUp() {
        // headers used by the service
        headerMap = new HashMap<>();
        headerMap.put("x-lbg-session-id", "sess");
        headerMap.put("x-lbg-txn-correlation-id", "cor");
        headerMap.put("x-lbg-brand", "SCW");

        // mock properties -> operations flow
        when(capLegacyProperties.getBaseUrl()).thenReturn(BASE_URL);
        when(capLegacyProperties.getOperations()).thenReturn(operations);

        when(operations.getCredentialEndpoint()).thenReturn(CREDENTIAL_ENDPOINT);
        when(operations.getEligibleAuthEndpoint()).thenReturn(ELIGIBLE_ENDPOINT);
        when(operations.getStore()).thenReturn("scw");
        when(operations.getPartition()).thenReturn("uk");
    }

    @Test
    void testGetLegacyCredential_Success() {
        String linkedCustomerId = "cust123";
        String userName = "john";

        LegacyCredentialResponse mockResponse = new LegacyCredentialResponse();

        // we don't care about the exact URL string, only that the call happens with these args
        when(lbgRestTemplate.executeGetRequest(
                anyString(),
                any(HttpEntity.class),
                eq(LegacyCredentialResponse.class),
                eq(linkedCustomerId),
                eq(userName))
        ).thenReturn(mockResponse);

        // Call service
        LegacyCredentialResponse result =
                legacyCredentialProxyService.getLegacyCredential(headerMap, linkedCustomerId, userName);

        // Assertions
        assertNotNull(result);
        assertEquals(mockResponse, result);
    }

    @Test
    void testGetEligibleAuthenticators_Success() {
        String customerId = "cust123";
        String credentialStore = "scw";

        CustomerInformationSystemResponse mockResponse = new CustomerInformationSystemResponse();

        // again, URL itself is not asserted, only parameters & type
        when(lbgRestTemplate.executeGetRequest(
                anyString(),
                any(HttpEntity.class),
                eq(CustomerInformationSystemResponse.class),
                eq(customerId),
                eq(credentialStore))
        ).thenReturn(mockResponse);

        // Call service
        CustomerInformationSystemResponse result =
                legacyCredentialProxyService.getEligibleAuthenticators(headerMap, customerId, credentialStore);

        // Assertions
        assertNotNull(result);
        assertEquals(mockResponse, result);
    }

    /*
    // If later you want a negative test, you can add something like:
    //
    // @Test
    // void testGetLegacyCredential_ErrorPath() {
    //     String linkedCustomerId = "cust123";
    //     String userName = "john";
    //
    //     when(lbgRestTemplate.executeGetRequest(
    //             anyString(),
    //             any(HttpEntity.class),
    //             eq(LegacyCredentialResponse.class),
    //             eq(linkedCustomerId),
    //             eq(userName))
    //     ).thenThrow(new RuntimeException("Boom"));
    //
    //     assertThrows(RuntimeException.class,
    //             () -> legacyCredentialProxyService.getLegacyCredential(headerMap, linkedCustomerId, userName));
    // }
    */
}

------------------------------------------------------------------
@BeforeEach
void setUp() {
    headerMap = new HashMap<>();
    headerMap.put("x-lbg-session-id", "sess");
    headerMap.put("x-lbg-txn-correlation-id", "cor");
    headerMap.put("x-lbg-brand", "SCW");

    when(operations.getCredentialEndpoint()).thenReturn("/credentials/{credentialStore}/{partition}");
    when(operations.getEligibleAuthEndpoint()).thenReturn("/eligible/{credentialStore}/{partition}");
    when(operations.getStore()).thenReturn("scw");
    when(operations.getPartition()).thenReturn("uk");
}

------------------------------
@ExtendWith(MockitoExtension.class)
class LegacyCredentialProxyServiceTest {

    @Mock
    private LbgRestTemplate lbgRestTemplate;

    @Mock
    private CapiLegacyProperties.Operations operations;

    @Mock
    private ErrorUtil errorUtil;

    @Spy
    @InjectMocks
    private LegacyCredentialProxyService legacyCredentialProxyService;

    private Map<String, String> headerMap;

    private static final String BASE_URL = "http://mock-capi1";
    private static final String ENDPOINT = "/credentials/{credentialStore}/{partition}";

    @BeforeEach
    void setUp() {
        // initialise header map
        headerMap = new HashMap<>();
        headerMap.put("x-lbg-session-id", "sess");
        headerMap.put("x-lbg-txn-correlation-id", "cor");
        headerMap.put("x-lbg-brand", "SCW");

        // if your service uses these in buildUrl(...)
        when(operations.getBaseUrl()).thenReturn(BASE_URL);
        when(operations.getCredentialEndpoint()).thenReturn(ENDPOINT);
    }

    @Test
    void testGetLegacyCredential_Success() {
        String linkedCustomerId = "cust123";
        String userName        = "john";

        LegacyCredentialResponse mockResponse = new LegacyCredentialResponse();

        when(lbgRestTemplate.executeGetRequest(
                anyString(),                       // URL constructed inside service
                any(HttpEntity.class),
                eq(LegacyCredentialResponse.class),
                eq(linkedCustomerId),
                eq(userName)))
            .thenReturn(mockResponse);

        // Call service
        LegacyCredentialResponse result =
                legacyCredentialProxyService.getLegacyCredential(headerMap, linkedCustomerId, userName);

        assertNotNull(result);
        assertEquals(mockResponse, result);
    }
}

--------------
@Test
void testGetEligibleAuthenticators_Success() {

    String customerId = "cust123";
    String credentialStore = "scw";

    CustomerInformationSystemResponse mockResponse = new CustomerInformationSystemResponse();

    // Mock URL builder (package-private method)
    doReturn("http://mock-eligible-url")
            .when(legacyCredentialProxyService)
            .buildEligibleAuthenticatorUrl(anyString(), anyString());

    // Mock RestTemplate call
    when(lbgRestTemplate.executeGetRequest(
            eq("http://mock-eligible-url"),
            any(HttpEntity.class),
            eq(CustomerInformationSystemResponse.class),
            eq(customerId),
            eq(credentialStore)
    )).thenReturn(mockResponse);

    // Call service
    CustomerInformationSystemResponse result =
            legacyCredentialProxyService.getEligibleAuthenticators(
                    headerMap, customerId, credentialStore);

    // Validate
    assertNotNull(result);
    assertEquals(mockResponse, result);
}
-----------------------------------------------------------------

@Test
void testGetEligibleAuthenticators_Failure() {

    String customerId = "cust123";
    String credentialStore = "scw";

    // Mock URL builder
    doReturn("http://mock-eligible-url")
            .when(legacyCredentialProxyService)
            .buildEligibleAuthenticatorUrl(anyString(), anyString());

    // Mock RestTemplate to throw exception
    when(lbgRestTemplate.executeGetRequest(
            anyString(),
            any(HttpEntity.class),
            eq(CustomerInformationSystemResponse.class),
            eq(customerId),
            eq(credentialStore)
    )).thenThrow(new RuntimeException("CAPI error"));

    assertThrows(
            CoordinatorException.class,
            () -> legacyCredentialProxyService.getEligibleAuthenticators(
                    headerMap, customerId, credentialStore)
    );
}




------------------
@Test
void testGetEligibleAuthenticators_Success() {

    String customerId = "cust123";
    String credentialStore = "scw";

    CustomerInformationSystemResponse mockResponse = new CustomerInformationSystemResponse();
    
    // Mock the URL builder
    doReturn("http://mock-eligible-url")
            .when(legacyCredentialProxyService)
            .buildEligibleAuthenticatorUrl(anyString(), anyString());

    // Mock RestTemplate call
    when(lbgRestTemplate.executeGetRequest(
            eq("http://mock-eligible-url"),
            any(HttpEntity.class),
            eq(CustomerInformationSystemResponse.class),
            eq(customerId),
            eq(credentialStore)
    )).thenReturn(mockResponse);

    // Call service
    CustomerInformationSystemResponse result =
            legacyCredentialProxyService.getEligibleAuthenticators(
                    headerMap, customerId, credentialStore);

    // Assertions
    assertNotNull(result);
    assertEquals(mockResponse, result);
}
----------------------------------------------------
@Test
void testGetEligibleAuthenticators_Failure() {

    String customerId = "cust123";
    String credentialStore = "scw";

    RuntimeException capiException = new RuntimeException("CAPI DOWN");

    // Mock URL builder
    doReturn("http://mock-eligible-url")
            .when(legacyCredentialProxyService)
            .buildEligibleAuthenticatorUrl(anyString(), anyString());

    // Mock RestTemplate to throw an exception
    when(lbgRestTemplate.executeGetRequest(
            eq("http://mock-eligible-url"),
            any(HttpEntity.class),
            eq(CustomerInformationSystemResponse.class),
            eq(customerId),
            eq(credentialStore)
    )).thenThrow(capiException);

    // Mock errorUtil to wrap exception into CoordinatorException
    CoordinatorException expectedException =
            new CoordinatorException("UNKNOWN_ERROR", "Error calling Eligible Authenticators CAPI");

    when(errorUtil.buildCoordinatorException(
            errorUtil.getUnknownError(), capiException
    )).thenReturn(expectedException);

    // Assert throw
    CoordinatorException thrown =
            assertThrows(CoordinatorException.class, () ->
                    legacyCredentialProxyService.getEligibleAuthenticators(
                            headerMap,
                            customerId,
                            credentialStore
                    )
            );

    // Validation
    assertEquals(expectedException, thrown);
}

------------------------------------------------------------------------------------------
FINAL CODE: getEligibleAuthenticators

public CustomerInformationSystemResponse getEligibleAuthenticators(
        Map<String, String> headerMap,
        String customerId,
        String credentialStore) {

    LOGEGER.info(headerMap, () -> "Calling Legacy Eligible Authenticators CAPI");

    // Build headers
    HttpEntity<?> requestEntity = new HttpEntity<>(buildHeaders(headerMap));

    // Build URL similar to getLegacyCredential()
    String url = buildEligibleAuthenticatorUrl(customerId, credentialStore);

    LOGEGER.debug(headerMap, () -> "Constructed Eligible Authenticators URL: " + url);

    try {
        return lbgRestTemplate.executeGetRequest(
                url,
                requestEntity,
                CustomerInformationSystemResponse.class,
                customerId,
                credentialStore
        );

    } catch (Exception ex) {
        LOGEGER.error(headerMap, () -> "Error calling Eligible Authenticators CAPI", ex);
        throw errorUtil.buildCoordinatorException(errorUtil.getUnknownError(), ex);
    }
}

-------------------------------
Step 2: Add build URL method

private String buildEligibleAuthenticatorUrl(String customerId, String credentialStore) {
    return String.format(
            CapiLegacyProperties.operations().getEligibleAuthEndpoint(),
            customerId,
            credentialStore
    );
}
-----------------------------------------
SUCCESS TEST ‚Äì Eligible Authenticators returned successfully

@ExtendWith(MockitoExtension.class)
class LegacyCredentialProxyServiceTest {

    @InjectMocks
    private LegacyCredentialProxyService proxyService;

    @Mock
    private LbgRestTemplate lbgRestTemplate;

    @Mock
    private ErrorUtil errorUtil;

    @Mock
    private ApplicationError unknownError;

    private Map<String, String> headerMap;

    @BeforeEach
    void setup() {
        headerMap = new HashMap<>();
        headerMap.put("x-lbg-session-id", "test-session");
        headerMap.put("x-lbg-txn-correlation-id", "corr-123");
    }

    @Test
    void testGetEligibleAuthenticators_success() {

        String customerId = "cust123";
        String credentialStore = "scw";

        String url = "http://localhost:8080/customers/" + customerId +
                "/customerInformationSystem/" + customerId + "/authenticators";

        // Mock response
        CustomerInformationSystemResponse mockResponse = new CustomerInformationSystemResponse();
        mockResponse.setEligibleAuthenticators(List.of(
                new EligibleAuthenticator("PASSWORD"),
                new EligibleAuthenticator("OTP")
        ));

        // Mock restTemplate call
        when(lbgRestTemplate.executeGetRequest(
                eq(url),
                any(),
                eq(CustomerInformationSystemResponse.class),
                eq(customerId),
                eq(credentialStore)
        )).thenReturn(mockResponse);

        // Spy URL builder if required
        Mockito.doReturn(url)
                .when(proxyService)
                .buildEligibleAuthenticatorUrl(customerId, credentialStore);

        // Call method
        CustomerInformationSystemResponse response =
                proxyService.getEligibleAuthenticators(headerMap, customerId, credentialStore);

        // Validate
        assertNotNull(response);
        assertEquals(2, response.getEligibleAuthenticators().size());
        assertEquals("PASSWORD", response.getEligibleAuthenticators().get(0).getType());
        assertEquals("OTP", response.getEligibleAuthenticators().get(1).getType());
    }
}
--------------------------------------
2. FAILURE TEST ‚Äì When CAPI throws exception

@Test
void testGetEligibleAuthenticators_failure_throwsCoordinatorException() {

    String customerId = "cust123";
    String credentialStore = "scw";

    String url = "http://localhost:8080/customers/" + customerId +
            "/customerInformationSystem/" + customerId + "/authenticators";

    Exception capiException = new RuntimeException("CAPI down");

    // Mock URL builder
    Mockito.doReturn(url)
            .when(proxyService)
            .buildEligibleAuthenticatorUrl(customerId, credentialStore);

    when(lbgRestTemplate.executeGetRequest(
            eq(url),
            any(),
            eq(CustomerInformationSystemResponse.class),
            eq(customerId),
            eq(credentialStore)
    )).thenThrow(capiException);

    // Mock errorUtil to return CoordinatorException
    CoordinatorException mockException =
            new CoordinatorException(unknownError, capiException);

    when(errorUtil.buildCoordinatorException(unknownError, capiException))
            .thenReturn(mockException);

    // Execute & assert
    CoordinatorException thrown = assertThrows(
            CoordinatorException.class,
            () -> proxyService.getEligibleAuthenticators(headerMap, customerId, credentialStore)
    );

    assertEquals(mockException, thrown);
}

-------------------------------------
curl -X GET "http://localhost:8080/iau-legacy-identity-consumable-api/v1/credentials/ida/PI_SCW?linkedCustomerId=27458002-02c2-4571-9041-6b518a3241&userName=barry@emaildomain.com" \
  -H "x-lbg-session-id: f81d4fae-7dec-11d0-a765-00a0c91e6bf" \
  -H "x-lbg-txn-correlation-id: f81d4fae-7dec-11d0-a765-00a0c91e6bf" \
  -H "x-lbg-brand: SCW" \
  -H "Content-Type: application/json"

------------------------------------------------------------------------
public Expectation[] legacyCredentials() {
    return new Expectation[] {
        new Expectation(
            request()
                .withMethod("GET")
                .withPath("/iau-legacy-identity-consumable-api/v1/credentials/ida/PI_SCW")
                .withQueryStringParameter("linkedCustomerId", "2745...1748")
                .withQueryStringParameter("userName", "barry@emaildomain.com")
                .withHeader("x-lbg-session-id", matching(".+"))
                .withHeader("x-lbg-txn-correlation-id", matching(".+"))
                .withHeader("x-lbg-brand", "SCW")
        ).thenRespond(
            response()
                .withStatusCode(200)
                .withHeader("Content-Type", "application/json")
                .withBody(readFileFromClasspathOrPath("expectations/legacy-credentials.json"))
        )
    };
}


---------------------------------------------------
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class LegacyCredential {

    private String credentialId;
    private String linkedCustomerId;
    private String userName;
    private String status;
    private String passwordStatus;
    private boolean isMfaSet;
    private List<String> group;
    private String accountCreationDate;
    private String lastStatusChangeDate;
    private String lastPasswordChangeDate;
    private String lastLoggedInTime;
    private String passwordExpiryDate;
    private int currentGlobalCounter;
}


----------------------------------------------------------------------------------
curl -X GET "http://localhost:8080/iau-legacy-identity-consumable-api/v1/credentials/ida/PI_SCW?linkedCustomerId=27458002-02c2-4571-9041-6b5018a3241&userName=barry@emaildomain.com" \
  -H "x-lbg-session-id: f81d4fae-7dec-11d0-a765-00a0c91e6bf" \
  -H "x-lbg-txn-correlation-id: f81d4fae-7dec-11d0-a765-00a0c91e6bf" \
  -H "x-lbg-brand: SCW" \
  -H "Content-Type: application/json"

------------------------------------------------------------
@ExtendWith(MockitoExtension.class)
class LegacyCredentialProxyServiceTest {

    @Mock
    private LbgRestTemplate lbgRestTemplate;

    @Mock
    private CapiLegacyProperties capiLegacyProperties;

    @Mock
    private CapiLegacyProperties.Operations operations;

    @Mock
    private ErrorUtil errorUtil;

    @Spy
    @InjectMocks
    private LegacyCredentialProxyService legacyCredentialProxyService;

    private Map<String, String> headerMap;

    private static final String BASE_URL = "http://mock-cap1";
    private static final String ENDPOINT = "/credentials/{credentialStore}/{partition}";

    @BeforeEach
    void init() {
        MockitoAnnotations.openMocks(this);  // üî• VERY IMPORTANT
        headerMap = new HashMap<>();
        headerMap.put("x-lbg-session-id", "sess");
        headerMap.put("x-lbg-txn-correlation-id", "cor");
        headerMap.put("x-lbg-brand", "SCW");

        // Mock property chain
        when(capiLegacyProperties.getBaseUrl()).thenReturn(BASE_URL);
        when(capiLegacyProperties.getOperations()).thenReturn(operations);
        when(operations.getCredentialEndpoint()).thenReturn(ENDPOINT);
        when(operations.getStore()).thenReturn("ida");
        when(operations.getPartition()).thenReturn("PI_SCW");

        // Mock buildUrl() override
        doReturn("http://mock-url")
                .when(legacyCredentialProxyService)
                .buildUrl(anyString(), anyString());
    }

    @Test
    void testGetLegacyCredential_Success() {

        String linkedCustomerId = "cust123";
        String userName = "john";

        LegacyCredentialResponse mockResponse = new LegacyCredentialResponse();

        when(lbgRestTemplate.executeGetRequest(
                eq("http://mock-url"),
                any(HttpEntity.class),
                eq(LegacyCredentialResponse.class),
                eq(linkedCustomerId),
                eq(userName)
        )).thenReturn(mockResponse);

        // Call service
        LegacyCredentialResponse result = legacyCredentialProxyService
                .getLegacyCredential(headerMap, linkedCustomerId, userName);

        assertNotNull(result);
        assertEquals(mockResponse, result);
    }
}

-------------------------------
package com.lbg.iau.ssi.coordinator.identity.resolver.service;

import com.lbg.iau.ssi.coordinator.common.LbgRestTemplate;
import com.lbg.iau.ssi.coordinator.identity.resolver.model.LegacyCredentialResponse;
import com.lbg.iau.ssi.coordinator.identity.resolver.properties.CapiLegacyProperties;
import com.lbg.iau.ssi.coordinator.identity.resolver.util.ErrorUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.util.ReflectionTestUtils;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.doReturn;

@ExtendWith(MockitoExtension.class)
class LegacyCredentialProxyServiceTest {

    @Mock private LbgRestTemplate lbgRestTemplate;
    @Mock private CapiLegacyProperties capiLegacyProperties;
    @Mock private CapiLegacyProperties.Operations operations;
    @Mock private ErrorUtil errorUtil;

    @InjectMocks
    private LegacyCredentialProxyService legacyCredentialProxyService;

    Map<String, String> headerMap;

    private static final String BASE_URL = "http://mock-capi";
    private static final String ENDPOINT = "/credentials/{credentialStore}/{partition}";

    @BeforeEach
    void setUp() {
        headerMap = new HashMap<>();
        headerMap.put("x-lbg-session-id", "sess");
        headerMap.put("x-lbg-txn-correlation-id", "corr");
        headerMap.put("x-lbg-brand", "SCW");

        // Mock properties
        when(capiLegacyProperties.getBaseUrl()).thenReturn(BASE_URL);
        when(capiLegacyProperties.getOperations()).thenReturn(operations);
        when(operations.getCredentialEndpoint()).thenReturn(ENDPOINT);
        when(operations.getStore()).thenReturn("ida");
        when(operations.getPartition()).thenReturn("PI_SCW");

        // Allow buildUrl override
        doReturn("http://mock-url").when(legacyCredentialProxyService)
                .buildUrl(anyString(), anyString());
    }

    @Test
    void testGetLegacyCredential_Success() {

        String linkedCustomerId = "cust123";
        String userName = "john";

        LegacyCredentialResponse mockResponse = new LegacyCredentialResponse();
        ResponseEntity<LegacyCredentialResponse> responseEntity =
                new ResponseEntity<>(mockResponse, HttpStatus.OK);

        when(lbgRestTemplate.executeGetRequest(
                eq("http://mock-url"),
                any(HttpEntity.class),
                eq(LegacyCredentialResponse.class),
                eq(linkedCustomerId),
                eq(userName)
        )).thenReturn(mockResponse);

        LegacyCredentialResponse result = legacyCredentialProxyService
                .getLegacyCredential(headerMap, linkedCustomerId, userName);

        assertNotNull(result);
        assertEquals(mockResponse, result);
    }

    @Test
    void testGetLegacyCredential_Exception() {

        String linkedCustomerId = "cust123";
        String userName = "john";

        when(lbgRestTemplate.executeGetRequest(
                anyString(),
                any(HttpEntity.class),
                eq(LegacyCredentialResponse.class),
                anyString(),
                anyString()
        )).thenThrow(new RuntimeException("CAPI Failure"));

        when(errorUtil.buildCoordinatorException(any(), any()))
                .thenReturn(new RuntimeException("Converted"));

        assertThrows(RuntimeException.class, () ->
                legacyCredentialProxyService.getLegacyCredential(
                        headerMap, linkedCustomerId, userName));
    }
}


--------------------------------------------------------------------------
LegacyCredentialProxyService

package com.lbg.iau.ssi.coordinator.identity.resolver.service;

import com.lbg.iau.ssi.coordinator.identity.resolver.config.CapiLegacyProperties;
import com.lbg.iau.ssi.coordinator.identity.resolver.model.LegacyCredentialResponse;
import com.lbg.iau.ssi.common.logging.ApplicationLogger;
import com.lbg.iau.ssi.common.logging.LoggerManager;
import com.lbg.iau.ssi.common.rest.LbgRestTemplate;
import com.lbg.iau.ssi.common.util.ErrorUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.Map;
import java.util.UUID;

@Service
public class LegacyCredentialProxyService {

    private static final ApplicationLogger LOGGER =
            LoggerManager.getApplicationLogger(LegacyCredentialProxyService.class);

    @Autowired
    private LbgRestTemplate lbgRestTemplate;

    @Autowired
    private CapiLegacyProperties capiLegacyProperties;

    @Autowired
    private ErrorUtil errorUtil;


    /**
     * SDID-style method to call Legacy Consumable API
     */
    public LegacyCredentialResponse getLegacyCredential(
            Map<String, String> headerMap,
            String linkedCustomerId,
            String userName) {

        LOGGER.info(headerMap, () -> "Calling Legacy Credential CAPI");

        // Build Headers (SDID style)
        HttpEntity<?> requestEntity = new HttpEntity<>(buildHeaders(headerMap));

        // Build URL (SDID style)
        String url = buildUrl(linkedCustomerId, userName);

        LOGGER.debug(headerMap, () -> "Constructed Legacy Credential URL: " + url);

        try {
            return lbgRestTemplate.executeGet(
                    url,
                    requestEntity,
                    LegacyCredentialResponse.class,
                    linkedCustomerId,
                    userName
            );

        } catch (Exception ex) {
            LOGGER.error(headerMap, () -> "Error calling Legacy Credential CAPI", ex);
            throw errorUtil.toDownstreamError(ex);
        }
    }



    /**
     * Build headers like SDID buildCapiHeaders()
     */
    private HttpHeaders buildHeaders(Map<String, String> headerMap) {
        HttpHeaders headers = new HttpHeaders();
        headers.setAll(headerMap);
        headers.set("x-lbg-session-id", UUID.randomUUID().toString());
        headers.set("x-lbg-txn-correlation-id", UUID.randomUUID().toString());
        headers.setContentType(MediaType.APPLICATION_JSON);
        return headers;
    }


    /**
     * Build URL in SDID style using UriComponentsBuilder
     */
    private String buildUrl(String linkedCustomerId, String userName) {

        return UriComponentsBuilder.fromHttpUrl(capiLegacyProperties.getBaseUrl())
                .path(capiLegacyProperties.getCredentialsEndpoint())
                .path("/")
                .path(capiLegacyProperties.getStore())
                .path("/")
                .path(capiLegacyProperties.getPartition())
                .queryParam("linkedCustomerId", linkedCustomerId)
                .queryParam("userName", userName)
                .toUriString();
    }

}


-------------------------------------------------------------------------------------------------------------------
public LegacyCredentialResponse getLegacyCredential(String linkedCustomerId, String userName) {

    try {

        // Build URL:  https://localhost:8080/iau-legacy-identity-consumable-api/v1/credentials/{store}/{partition}
        String url = UriComponentsBuilder
                .fromUriString(capiLegacyProperties.getBaseUrl())
                .path("/credentials/")
                .path(capiLegacyProperties.getCredentialStore())
                .path("/")
                .path(capiLegacyProperties.getPartition())
                .queryParam("linkedCustomerId", linkedCustomerId)
                .queryParam("userName", userName)
                .build()
                .toString();

        // Prepare headers
        HttpHeaders headers = new HttpHeaders();
        headers.add("x-lbg-session-id", UUID.randomUUID().toString());
        headers.add("x-lbg-txn-correlation-id", UUID.randomUUID().toString());
        headers.add("x-lbg-brand", "SCW");
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Void> entity = new HttpEntity<>(headers);

        // Call downstream
        LOGGER.info("Calling Legacy Consumable API: {}", url);

        ResponseEntity<LegacyCredentialResponse> response =
                lbgRestTemplate.exchange(
                        url,
                        HttpMethod.GET,
                        entity,
                        LegacyCredentialResponse.class
                );

        return response.getBody();

    } catch (HttpStatusCodeException ex) {
        LOGGER.error("Downstream error: {}", ex.getResponseBodyAsString());
        throw errorUtil.toDownstreamError(ex);
    } catch (Exception ex) {
        LOGGER.error("Unknown error calling legacy API", ex);
        throw errorUtil.toGenericError(ex);
    }
}


------------------------------------------
1. Write the full mock method

public Expectation[] legacyCredentials() {
    return new Expectation[] {
        new Expectation(
            request()
                .withMethod("GET")
                .withPath("/iau-legacy-identity-consumable-api/v1/credentials/ida/PI_SCW")
                .withQueryStringParameter("linkedCustomerId", "2745...1748")
                .withQueryStringParameter("userName", "barry@emaildomain.com")
        ).thenRespond(
            response()
                .withStatusCode(200)
                .withHeader("Content-Type", "application/json")
                .withBody(readFileFromClassPathOrPath("expectations/legacy-credentials.json"))
        )
    };
}
------------------------
2. Add the JSON response file

src/test/resources/expectations/legacy-credentials.json

{
  "credentialId": "123e4567-e89b-12d3-a456-426614174000",
  "linkedCustomerId": "27458002-02c2-4571-9041-6b518a241748",
  "userName": "barry@emaildomain.com",
  "status": "ACTIVE",
  "passwordStatus": "A",
  "isMfaSet": true,
  "group": ["BLH", "JAG", "HAL", "LDR", "IB", "BOS", "SZX", "SCW"],
  "accountCreationDate": "2024-01-11T13:26:41.253Z",
  "lastStatusChangeDate": "2024-01-11T13:26:41.253Z",
  "lastPasswordChangeDate": "2024-01-11T13:26:41.253Z",
  "lastLoggedInTime": "2024-01-11T13:26:41.253Z",
  "passwordExpiryDate": "2024-01-11T13:26:41.253Z",
  "currentGlobalCounter": 0
}
---------------------------------------------
3. Register the new mock inside initializeExpectations()

return Stream.of(
    credentials(), cache(), customers(), session(),
    card_reader(), mi(), sdid(),
    legacyCredentials()     // üëâ ADD THIS
)
----------------------------------------------------------------------
4. Verify the path matches Swagger exactly

GET /credentials/{credentialStore}/{partition}
For your test case:

credentialStore ‚Üí ida

partition ‚Üí PI_SCW

So final path:
/iau-legacy-identity-consumable-api/v1/credentials/ida/PI_SCW
------------------------------------------------------------------------------------
5. Start MockServer and test the URL manually

http://localhost:1080/iau-legacy-identity-consumable-api/v1/credentials/ida/PI_SCW?linkedCustomerId=2745...1748&userName=barry@emaildomain.com

