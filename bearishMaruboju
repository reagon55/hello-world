 private String journeyState;
    private String defaultAuthenticator;
    private List<String> nextSteps;
    private Boolean dynamicLinkingEnabled;
    private List<String> possibleJourneyStates;
    private List<MiPosition> miPositions;
    private List<String> eligibleAuthenticators;


----------------------

{
  "journeyState": "AWAITING_PASSWORD",
  "defaultAuthenticator": "password",
  "nextSteps": ["SUBMIT_PASSWORD","AWAITING_MEMORABLE_INFORMATION"],
  "dynamicLinkingEnabled": false,
  "possibleJourneyStates": ["AWAITING_PASSWORD","AWAITING_MEMORABLE_INFORMATION"],
  "miPositions": [
    {"pos": "5"},
    {"pos": "1"},
    {"pos": "3"}
  ],
  "eligibleAuthenticators": ["password","mi"]
}

----------------------------------

package com.lbg.iau.ssi.coordinator.fetch.properties;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CapiMemorableInformationProperties.class)
@TestPropertySource(properties = {
        "services.capi.memorable-information-challenge-generator.baseUrl=http://localhost:1080/",
        "services.capi.memorable-information-challenge-generator.regChannelVersion=v1",
        "services.capi.memorable-information-challenge-generator.operations.memorableInformationChallengeCode=memorable-information-challenge-generator/"
})
class CapiMemorableInformationPropertiesTest {

    private CapiMemorableInformationProperties properties;

    @BeforeEach
    void setUp() {
        properties = new CapiMemorableInformationProperties();
        properties.setBaseUrl("http://localhost:1080/");
        properties.setRegChannelVersion("v1");

        CapiMemorableInformationProperties.Operations operations =
                new CapiMemorableInformationProperties.Operations();
        operations.setMemorableInformationChallengeCode("memorable-information-challenge-generator/");
        properties.setOperations(operations);
    }

    @Test
    void testPropertyBinding() {
        assertEquals("http://localhost:1080/", properties.getBaseUrl());
        assertEquals("v1", properties.getRegChannelVersion());
        assertEquals("memorable-information-challenge-generator/",
                properties.getOperations().getMemorableInformationChallengeCode());
    }

    @Test
    void testGetFullUrl() {
        String expected = "http://localhost:1080/memorable-information-challenge-generator/";
        String actual = properties.getBaseUrl() +
                properties.getOperations().getMemorableInformationChallengeCode();
        assertEquals(expected, actual);
    }

    @Test
    void testValidatePropertiesThrowsExceptionWhenInvalid() {
        CapiMemorableInformationProperties invalidProps = new CapiMemorableInformationProperties();

        IllegalStateException exception = assertThrows(IllegalStateException.class,
                invalidProps::validateProperties);

        assertEquals("CapiMemorableInformationProperties is not properly configured", exception.getMessage());
    }

    @Test
    void testValidatePropertiesPassesWhenValid() {
        assertDoesNotThrow(properties::validateProperties);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
package com.lbg.iau.ssi.coordinator.fetch.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.lbg.iau.ssi.coordinator.fetch.exception.CoordinatorException;
import com.lbg.iau.ssi.coordinator.fetch.exception.ErrorConfig;
import com.lbg.iau.ssi.coordinator.fetch.properties.CapimMemorableInformationProperties;
import com.lbg.iau.ssi.coordinator.fetch.proxy.CacheMgmntProxyService;
import com.lbg.lau.ssi.contractor.model.JourneyState;
import com.lbg.lau.ssi.contractor.model.MiPositions;
import com.lbg.lau.ssi.contractor.common.LbgRestTemplate;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.ClassPathResource;

import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;

import static com.lbg.iau.ssi.coordinator.fetch.util.Constants.CREDENTIAL_ID_KEY;
import static com.lbg.iau.ssi.coordinator.fetch.util.Constants.CREDENTIAL_STORE_KEY;
import static com.lbg.iau.ssi.coordinator.fetch.util.Constants.PARTITION_KEY;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class MiChallengeServiceImplTest {

    @Mock
    private LbgRestTemplate memorableInformationRestTemplate;

    @Mock
    private CapimMemorableInformationProperties memorableInformationProperties;

    @Mock
    private CacheMgmntProxyService cacheMgmntProxyService;

    @Mock
    private ErrorConfig errorConfig;

    @InjectMocks
    private MiChallengeServiceImpl miChallengeService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    /** ✅ Success Scenario */
    @Test
    void testGetMiChallenge_success() throws Exception {

        // ---- Load fake JSON from test/resources ----
        String json = Files.readString(new ClassPathResource("expectations/mi-challenge-success.json").getFile().toPath());
        MiPositions expectedResponse = objectMapper.readValue(json, MiPositions.class);

        // ---- Mock Journey State ----
        JourneyState journeyState = mock(JourneyState.class);
        Map<String, String> data = new HashMap<>();
        data.put(CREDENTIAL_ID_KEY, "cred123");
        data.put(CREDENTIAL_STORE_KEY, "store1");
        data.put(PARTITION_KEY, "p1");

        when(journeyState.getData()).thenReturn(data);
        when(cacheMgmntProxyService.getJourneyStateBySessionId(any())).thenReturn(journeyState);

        // ---- Mock RestTemplate ----
        when(memorableInformationRestTemplate.executeGetRequest(
                any(),
                eq(MiPositions.class),
                any(),
                any(),
                any()
        )).thenReturn(expectedResponse);

        when(memorableInformationProperties.getOperations().getMemorableInformationChallengeCode())
                .thenReturn("/challenge/api");

        // ---- Call Method ----
        MiPositions actual = miChallengeService.getMiChallenge(new HashMap<>(), "sessionHeaders");

        // ---- Assertions ----
        assertNotNull(actual);
        assertEquals(expectedResponse, actual);
        verify(memorableInformationRestTemplate, times(1))
                .executeGetRequest(any(), eq(MiPositions.class), any(), any(), any());
    }

    /** ❌ Negative Scenario (credentialId missing) */
    @Test
    void testGetMiChallenge_missingRequiredValues_throwsException() {

        JourneyState journeyState = mock(JourneyState.class);
        Map<String, String> data = new HashMap<>(); // ← returning empty map forces null
        when(journeyState.getData()).thenReturn(data);
        when(cacheMgmntProxyService.getJourneyStateBySessionId(any())).thenReturn(journeyState);

        assertThrows(CoordinatorException.class,
                () -> miChallengeService.getMiChallenge(new HashMap<>(), "sessionHeaders"));
    }
}


-----------------fake joson----------------------
mi-challenge-success.json

{
  "sessionId": "SESSION-1001",
  "status": "SUCCESS",
  "message": "Memorable Information challenge generated successfully",
  "challengePositions": [
    {
      "positionId": "MI-01",
      "label": "Enter 1st character",
      "maskIndex": 1
    },
    {
      "positionId": "MI-03",
      "label": "Enter 3rd character",
      "maskIndex": 3
    },
    {
      "positionId": "MI-05",
      "label": "Enter 5th character",
      "maskIndex": 5
    }
  ]
}
---------------
mi-challenge-fail.json

{
  "sessionId": "SESSION-1001",
  "status": "FAILURE",
  "message": "Unable to generate MI challenge",
  "error": {
    "code": "MI_ERR_401",
    "details": "Invalid credential store or partition"
  }
}

------------------------------------------------
@Test
void testGetMiChallenge_failureResponse_fromDownstream() throws Exception {
    String json = Files.readString(
        new ClassPathResource("expectations/mi-challenge-fail.json").getFile().toPath()
    );

    MiPositions failResponse = objectMapper.readValue(json, MiPositions.class);

    JourneyState journeyState = mock(JourneyState.class);
    Map<String, String> data = new HashMap<>();
    data.put(CREDENTIAL_ID_KEY, "cred123");
    data.put(CREDENTIAL_STORE_KEY, "store1");
    data.put(PARTITION_KEY, "p1");

    when(journeyState.getData()).thenReturn(data);
    when(cacheMgmntProxyService.getJourneyStateBySessionId(any()))
            .thenReturn(journeyState);

    when(memorableInformationRestTemplate.executeGetRequest(any(), eq(MiPositions.class), any(), any(), any()))
            .thenReturn(failResponse);

    assertThrows(CoordinatorException.class, () ->
            miChallengeService.getMiChallenge(new HashMap<>(), "header")
    );
}



