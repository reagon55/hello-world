package com.lbg.iau.ssi.coordinator.fetch.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.lbg.iau.ssi.coordinator.fetch.model.MiPositions;
import com.lbg.iau.ssi.coordinator.fetch.properties.CapiMemorableInformationProperties;
import com.lbg.iau.ssi.coordinator.fetch.properties.CapiMemorableInformationProperties.Operations;
import com.lbg.iau.ssi.coordinator.fetch.rest.LbgRestTemplate;
import com.lbg.iau.ssi.coordinator.fetch.config.ErrorConfig;
import com.lbg.iau.ssi.coordinator.fetch.exception.CoordinatorException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentMatchers;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.nio.file.Files;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class MiChallengeServiceImplTest {

    @Mock
    private LbgRestTemplate memorableInformationRestTemplate;

    @Mock
    private CapiMemorableInformationProperties memorableInformationProperties;

    @Mock
    private ErrorConfig errorConfig;

    // any other mocks your service needs (from screenshots)
    @Mock
    private CacheMgmtProxyService cacheMgmtProxyService;

    @InjectMocks
    private MiChallengeServiceImpl miChallengeService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void testGetMiChallenge_success() throws Exception {
        // load expected JSON from your test resources (adjust path to match your project)
        String json = Files.readString(new java.io.ClassPathResource("expectations/mi-challenge-success-Service.json").getFile().toPath());
        MiPositions expectedResponse = objectMapper.readValue(json, MiPositions.class);

        // --- mock / stub nested objects to avoid NPE ---
        Operations ops = mock(Operations.class);
        when(memorableInformationProperties.getOperations()).thenReturn(ops);

        // service expects a path string from operations
        when(ops.getMemorableInformationChallengeCode()).thenReturn("/challenge/api");
        // do NOT call a non-existent getter (your IDE complained). If your real Operations has authenticators,
        // stub the real method, otherwise skip it.

        // --- mock rest template downstream call ---
        when(memorableInformationRestTemplate.executeGetRequest(
                anyString(),
                ArgumentMatchers.<org.springframework.http.HttpEntity<Object>>any(),
                eq(MiPositions.class),
                anyMap(),
                any(ErrorConfig.class),
                anyMap()
        )).thenReturn(expectedResponse);

        // --- call method under test ---
        Map<String, String> sessionHeaders = new HashMap<>();
        sessionHeaders.put("sessionHeaders", "dummy-value");

        MiPositions actual = miChallengeService.getMiChallenge(sessionHeaders);

        // --- assertions & verify ---
        assertNotNull(actual);
        assertEquals(expectedResponse, actual);

        verify(memorableInformationRestTemplate, times(1)).executeGetRequest(
                anyString(),
                ArgumentMatchers.<org.springframework.http.HttpEntity<Object>>any(),
                eq(MiPositions.class),
                anyMap(),
                any(ErrorConfig.class),
                anyMap()
        );
    }

    @Test
    void testGetMiChallenge_failureFromDownstream_throwsCoordinatorException() throws Exception {
        // load failure JSON
        String json = Files.readString(new java.io.ClassPathResource("expectations/mi-challenge-fail.json").getFile().toPath());
        MiPositions failResponse = objectMapper.readValue(json, MiPositions.class);

        // stub nested ops same as above to avoid NPE
        Operations ops = mock(Operations.class);
        when(memorableInformationProperties.getOperations()).thenReturn(ops);
        when(ops.getMemorableInformationChallengeCode()).thenReturn("/challenge/api");

        // make rest template return a failure payload (your service should translate to CoordinatorException)
        when(memorableInformationRestTemplate.executeGetRequest(
                anyString(),
                ArgumentMatchers.<org.springframework.http.HttpEntity<Object>>any(),
                eq(MiPositions.class),
                anyMap(),
                any(ErrorConfig.class),
                anyMap()
        )).thenReturn(failResponse);

        // assert that service surfaces the expected exception type (adjust if your service returns another)
        Map<String, String> sessionHeaders = new HashMap<>();
        sessionHeaders.put("sessionHeaders", "dummy-value");

        assertThrows(CoordinatorException.class, () -> miChallengeService.getMiChallenge(sessionHeaders));
    }
}
------------


private String journeyState;
    private String defaultAuthenticator;
    private List<String> nextSteps;
    private Boolean dynamicLinkingEnabled;
    private List<String> possibleJourneyStates;
    private List<MiPosition> miPositions;
    private List<String> eligibleAuthenticators;


----------------------

{
  "journeyState": "AWAITING_PASSWORD",
  "defaultAuthenticator": "password",
  "nextSteps": ["SUBMIT_PASSWORD","AWAITING_MEMORABLE_INFORMATION"],
  "dynamicLinkingEnabled": false,
  "possibleJourneyStates": ["AWAITING_PASSWORD","AWAITING_MEMORABLE_INFORMATION"],
  "miPositions": [
    {"pos": "5"},
    {"pos": "1"},
    {"pos": "3"}
  ],
  "eligibleAuthenticators": ["password","mi"]
}

----------------------------------

package com.lbg.iau.ssi.coordinator.fetch.properties;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = CapiMemorableInformationProperties.class)
@TestPropertySource(properties = {
        "services.capi.memorable-information-challenge-generator.baseUrl=http://localhost:1080/",
        "services.capi.memorable-information-challenge-generator.regChannelVersion=v1",
        "services.capi.memorable-information-challenge-generator.operations.memorableInformationChallengeCode=memorable-information-challenge-generator/"
})
class CapiMemorableInformationPropertiesTest {

    private CapiMemorableInformationProperties properties;

    @BeforeEach
    void setUp() {
        properties = new CapiMemorableInformationProperties();
        properties.setBaseUrl("http://localhost:1080/");
        properties.setRegChannelVersion("v1");

        CapiMemorableInformationProperties.Operations operations =
                new CapiMemorableInformationProperties.Operations();
        operations.setMemorableInformationChallengeCode("memorable-information-challenge-generator/");
        properties.setOperations(operations);
    }

    @Test
    void testPropertyBinding() {
        assertEquals("http://localhost:1080/", properties.getBaseUrl());
        assertEquals("v1", properties.getRegChannelVersion());
        assertEquals("memorable-information-challenge-generator/",
                properties.getOperations().getMemorableInformationChallengeCode());
    }

    @Test
    void testGetFullUrl() {
        String expected = "http://localhost:1080/memorable-information-challenge-generator/";
        String actual = properties.getBaseUrl() +
                properties.getOperations().getMemorableInformationChallengeCode();
        assertEquals(expected, actual);
    }

    @Test
    void testValidatePropertiesThrowsExceptionWhenInvalid() {
        CapiMemorableInformationProperties invalidProps = new CapiMemorableInformationProperties();

        IllegalStateException exception = assertThrows(IllegalStateException.class,
                invalidProps::validateProperties);

        assertEquals("CapiMemorableInformationProperties is not properly configured", exception.getMessage());
    }

    @Test
    void testValidatePropertiesPassesWhenValid() {
        assertDoesNotThrow(properties::validateProperties);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
package com.lbg.iau.ssi.coordinator.fetch.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.lbg.iau.ssi.coordinator.fetch.exception.CoordinatorException;
import com.lbg.iau.ssi.coordinator.fetch.exception.ErrorConfig;
import com.lbg.iau.ssi.coordinator.fetch.properties.CapimMemorableInformationProperties;
import com.lbg.iau.ssi.coordinator.fetch.proxy.CacheMgmntProxyService;
import com.lbg.lau.ssi.contractor.model.JourneyState;
import com.lbg.lau.ssi.contractor.model.MiPositions;
import com.lbg.lau.ssi.contractor.common.LbgRestTemplate;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.ClassPathResource;

import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;

import static com.lbg.iau.ssi.coordinator.fetch.util.Constants.CREDENTIAL_ID_KEY;
import static com.lbg.iau.ssi.coordinator.fetch.util.Constants.CREDENTIAL_STORE_KEY;
import static com.lbg.iau.ssi.coordinator.fetch.util.Constants.PARTITION_KEY;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class MiChallengeServiceImplTest {

    @Mock
    private LbgRestTemplate memorableInformationRestTemplate;

    @Mock
    private CapimMemorableInformationProperties memorableInformationProperties;

    @Mock
    private CacheMgmntProxyService cacheMgmntProxyService;

    @Mock
    private ErrorConfig errorConfig;

    @InjectMocks
    private MiChallengeServiceImpl miChallengeService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    /** ✅ Success Scenario */
    @Test
    void testGetMiChallenge_success() throws Exception {

        // ---- Load fake JSON from test/resources ----
        String json = Files.readString(new ClassPathResource("expectations/mi-challenge-success.json").getFile().toPath());
        MiPositions expectedResponse = objectMapper.readValue(json, MiPositions.class);

        // ---- Mock Journey State ----
        JourneyState journeyState = mock(JourneyState.class);
        Map<String, String> data = new HashMap<>();
        data.put(CREDENTIAL_ID_KEY, "cred123");
        data.put(CREDENTIAL_STORE_KEY, "store1");
        data.put(PARTITION_KEY, "p1");

        when(journeyState.getData()).thenReturn(data);
        when(cacheMgmntProxyService.getJourneyStateBySessionId(any())).thenReturn(journeyState);

        // ---- Mock RestTemplate ----
        when(memorableInformationRestTemplate.executeGetRequest(
                any(),
                eq(MiPositions.class),
                any(),
                any(),
                any()
        )).thenReturn(expectedResponse);

        when(memorableInformationProperties.getOperations().getMemorableInformationChallengeCode())
                .thenReturn("/challenge/api");

        // ---- Call Method ----
        MiPositions actual = miChallengeService.getMiChallenge(new HashMap<>(), "sessionHeaders");

        // ---- Assertions ----
        assertNotNull(actual);
        assertEquals(expectedResponse, actual);
        verify(memorableInformationRestTemplate, times(1))
                .executeGetRequest(any(), eq(MiPositions.class), any(), any(), any());
    }

    /** ❌ Negative Scenario (credentialId missing) */
    @Test
    void testGetMiChallenge_missingRequiredValues_throwsException() {

        JourneyState journeyState = mock(JourneyState.class);
        Map<String, String> data = new HashMap<>(); // ← returning empty map forces null
        when(journeyState.getData()).thenReturn(data);
        when(cacheMgmntProxyService.getJourneyStateBySessionId(any())).thenReturn(journeyState);

        assertThrows(CoordinatorException.class,
                () -> miChallengeService.getMiChallenge(new HashMap<>(), "sessionHeaders"));
    }
}


-----------------fake joson----------------------
mi-challenge-success.json

{
  "sessionId": "SESSION-1001",
  "status": "SUCCESS",
  "message": "Memorable Information challenge generated successfully",
  "challengePositions": [
    {
      "positionId": "MI-01",
      "label": "Enter 1st character",
      "maskIndex": 1
    },
    {
      "positionId": "MI-03",
      "label": "Enter 3rd character",
      "maskIndex": 3
    },
    {
      "positionId": "MI-05",
      "label": "Enter 5th character",
      "maskIndex": 5
    }
  ]
}
---------------
mi-challenge-fail.json

{
  "sessionId": "SESSION-1001",
  "status": "FAILURE",
  "message": "Unable to generate MI challenge",
  "error": {
    "code": "MI_ERR_401",
    "details": "Invalid credential store or partition"
  }
}

------------------------------------------------
@Test
void testGetMiChallenge_failureResponse_fromDownstream() throws Exception {
    String json = Files.readString(
        new ClassPathResource("expectations/mi-challenge-fail.json").getFile().toPath()
    );

    MiPositions failResponse = objectMapper.readValue(json, MiPositions.class);

    JourneyState journeyState = mock(JourneyState.class);
    Map<String, String> data = new HashMap<>();
    data.put(CREDENTIAL_ID_KEY, "cred123");
    data.put(CREDENTIAL_STORE_KEY, "store1");
    data.put(PARTITION_KEY, "p1");

    when(journeyState.getData()).thenReturn(data);
    when(cacheMgmntProxyService.getJourneyStateBySessionId(any()))
            .thenReturn(journeyState);

    when(memorableInformationRestTemplate.executeGetRequest(any(), eq(MiPositions.class), any(), any(), any()))
            .thenReturn(failResponse);

    assertThrows(CoordinatorException.class, () ->
            miChallengeService.getMiChallenge(new HashMap<>(), "header")
    );
}
------------------------
package com.lbg.iau.ssi.coordinator.fetch.service; // <- adjust to your package

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyMap;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.times;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.nio.file.Files;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentMatchers;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.ClassPathResource;
import org.springframework.http.HttpEntity;

import com.fasterxml.jackson.databind.ObjectMapper;

@ExtendWith(MockitoExtension.class)
class MiChallengeServiceImplTest {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Mock
    private LbgRestTemplate memorableInformationRestTemplate;

    @Mock
    private CapiMemorableInformationProperties memorableInformationProperties;

    @Mock
    private CacheMgmtProxyService cacheMgmtProxyService;

    @Mock
    private ErrorConfig errorConfig;

    @InjectMocks
    private MiChallengeServiceImpl miChallengeService;

    @Test
    void testGetMiChallenge_success() throws Exception {
        // load expected response from test resources
        String json = Files.readString(new ClassPathResource("expectations/mi-challenge-success-Service.json").getFile().toPath());
        MiPositions expectedResponse = objectMapper.readValue(json, MiPositions.class);

        // --- mock journey state and cache
        JourneyState journeyState = Mockito.mock(JourneyState.class);
        Map<String, String> data = new HashMap<>();
        data.put("CREDENTIAL_ID_KEY", "cred123");
        data.put("CREDENTIAL_STORE_KEY", "store1");
        data.put("partitionKey", "p1");

        when(journeyState.getData()).thenReturn(data);
        when(cacheMgmtProxyService.getJourneyStateBySessionId(any())).thenReturn(journeyState);

        // --- mock RestTemplate call (typed)
        when(memorableInformationRestTemplate.executeGetRequest(
                anyString(),
                ArgumentMatchers.<HttpEntity<Object>>any(),
                eq(MiPositions.class),
                anyMap(),
                any(ErrorConfig.class),
                anyMap()
        )).thenReturn(expectedResponse);

        // --- IMPORTANT: stub nested Operations to avoid NPE
        CapiMemorableInformationProperties.Operations ops = Mockito.mock(CapiMemorableInformationProperties.Operations.class);
        when(memorableInformationProperties.getOperations()).thenReturn(ops);
        // service expects a string path and maybe authenticators list — give sensible defaults
        when(ops.getMemorableInformationChallengeCode()).thenReturn("/challenge/api");
        when(ops.getAuthenticators()).thenReturn(Collections.emptyList());

        // --- call method under test
        Map<String, String> sessionHeaders = new HashMap<>();
        sessionHeaders.put("sessionHeaders", "dummy-value");

        MiPositions actual = miChallengeService.getMiChallenge(sessionHeaders);

        // --- assertions & verify
        assertNotNull(actual);
        assertEquals(expectedResponse, actual);

        verify(memorableInformationRestTemplate, times(1)).executeGetRequest(
                anyString(),
                ArgumentMatchers.<HttpEntity<Object>>any(),
                eq(MiPositions.class),
                anyMap(),
                any(ErrorConfig.class),
                anyMap()
        );
    }

    @Test
    void testGetMiChallenge_failureResponseFromDownstream() throws Exception {
        // load a failure mi-positions JSON (if you have one)
        String json = Files.readString(new ClassPathResource("expectations/mi-challenge-fail.json").getFile().toPath());
        MiPositions failResponse = objectMapper.readValue(json, MiPositions.class);

        // similar basic stubs as success
        JourneyState journeyState = Mockito.mock(JourneyState.class);
        Map<String, String> data = new HashMap<>();
        data.put("CREDENTIAL_ID_KEY", "cred123");
        data.put("CREDENTIAL_STORE_KEY", "store1");
        data.put("partitionKey", "p1");

        when(journeyState.getData()).thenReturn(data);
        when(cacheMgmtProxyService.getJourneyStateBySessionId(any())).thenReturn(journeyState);

        // stub rest template to return failure payload
        when(memorableInformationRestTemplate.executeGetRequest(
                anyString(),
                ArgumentMatchers.<HttpEntity<Object>>any(),
                eq(MiPositions.class),
                anyMap(),
                any(ErrorConfig.class),
                anyMap()
        )).thenReturn(failResponse);

        // stub nested ops
        CapiMemorableInformationProperties.Operations ops = Mockito.mock(CapiMemorableInformationProperties.Operations.class);
        when(memorableInformationProperties.getOperations()).thenReturn(ops);
        when(ops.getMemorableInformationChallengeCode()).thenReturn("/challenge/api");
        when(ops.getAuthenticators()).thenReturn(Collections.emptyList());

        // Expect your service to throw CoordinatorException (adjust if different)
        org.junit.jupiter.api.Assertions.assertThrows(CoordinatorException.class, () -> {
            miChallengeService.getMiChallenge(Collections.emptyMap());
        });
    }
}




